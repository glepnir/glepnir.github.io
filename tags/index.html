<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png }><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content="Tags"><link rel=alternate type=application/rss+xml href=https://www.functor.me/tags/index.xml title="glepnir's blog"><title>Tags | glepnir's blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.0e9c0bb0a7de7a330263937778a4d7c0d0c6be7f327c69a0223c9f2fd31e00d5.css media=all></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/><u>H</u>ome</a></li><li><a tabindex=-1 class=menu-link href=/tags><u>T</u>ags</a></li></ul></nav><h1>Tags</h1><ul class=terms><li><a href=/tags/color-science/>Color-Science</a> - 1</li><li><a href=/tags/neovim/>Neovim</a> - 1</li><li><a href=/tags/oklab/>Oklab</a> - 1</li><li><a href=/tags/vision-research/>Vision-Research</a> - 1</li></ul><br><footer class=site-footer><p class=footer-meta>¬© 2025 glepnir ¬∑
<a href=https://github.com/glepnir>GitHub</a> ¬∑
<a href=https://reddit.com/u/glephunter>Reddit</a> ¬∑
<a href=https://www.functor.me/index.xml>RSS</a></p><script defer>document.addEventListener("keydown",function(e){if(document.activeElement.isContentEditable)return!1;if(document.activeElement.tagName=="INPUT")return!1;if(e.altKey||e.ctrlKey||e.shiftKey)return!1;var t=e.key;if(t==="h")e.preventDefault(),e.stopPropagation(),window.location.href="/";else if(t==="t")e.preventDefault(),e.stopPropagation(),window.location.href=`https://${location.hostname}/tags`;else if(t==="i"){e.preventDefault(),e.stopPropagation();const t=document.querySelectorAll("input");for(let e=0;e<t.length;e++)if(t[e].offsetParent!==null){t[e].selectionStart=t[e].selectionEnd=t[e].value.length,t[e].focus();break}}return!1})</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,200))}setTimeout(scrollHandler,100)</script><script defer>function getTextContentRecursively(e){let t="";if(e.nodeType===Node.TEXT_NODE)return e.textContent||"";for(const n of e.childNodes)t+=getTextContentRecursively(n);return t}function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]:not(.output):not([class*="language-console"])');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const n=getTextContentRecursively(e);navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script>window.store={"https://www.functor.me/":{title:"glepnir's blog",tags:[],content:"",url:"https://www.functor.me/"},"https://www.functor.me/posts/":{title:"Posts",tags:[],content:"",url:"https://www.functor.me/posts/"},"https://www.functor.me/posts/thought_fp/":{title:"When Loops Become Math: How Functional Thinking Changed My C++",tags:[],content:`Last week, I was staring at two pieces of code a friend had sent me, asking which one I preferred. They looked like this:
// Version A double calculate_mean(const vector&lt;double&gt;&amp; data) { double sum = 0.0; for (const auto&amp; x : data) { sum += x; } return sum / data.size(); } // Version B double calculate_stddev(const vector&lt;double&gt;&amp; data) { double sum = 0.0; double mean = calculate_mean(data); for (const auto&amp; x : data) { sum += (x - mean) * (x - mean); } return sqrt(sum / data.size()); } I looked at them for a solid five seconds before it hit me: these two loops were fundamentally the same mathematical pattern! But in the code, that pattern was buried under for loops and accumulation variables.
Seeing with Math Eyes In math, we&rsquo;d write these calculations as:
mean=1n‚àëi=1nxi \\text{mean} = \\frac{1}{n} \\sum_{i=1}^n x_i mean=n1‚Äãi=1‚àën‚Äãxi‚Äãstddev=1n‚àëi=1n(xi‚àíŒº)2 \\text{stddev} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2} stddev=n1‚Äãi=1‚àën‚Äã(xi‚Äã‚àíŒº)2‚ÄãSee that $\\sum$ symbol? That&rsquo;s our abstraction point. In functional programming, this is called a fold (or reduce), defined as:
fold(f,z,[x1,x2,...,xn])=f(f(f(z,x1),x2),...,xn) \\text{fold}(f, z, [x_1, x_2, ..., x_n]) = f(f(f(z, x_1), x_2), ..., x_n) fold(f,z,[x1‚Äã,x2‚Äã,...,xn‚Äã])=f(f(f(z,x1‚Äã),x2‚Äã),...,xn‚Äã)Looking at my code with this new perspective:
template&lt;typename T, typename BinaryOp&gt; T fold(const vector&lt;T&gt;&amp; vec, T init, BinaryOp op) { T result = init; for (const auto&amp; x : vec) { result = op(result, x); } return result; } Now both calculations become:
double mean = fold(data, 0.0, plus&lt;double&gt;{}) / data.size(); double variance = fold(data, 0.0, [mean](double acc, double x) { return acc + (x - mean) * (x - mean); }) / data.size(); The Real Breakthrough: Seeing Deeper Patterns I started noticing this pattern everywhere. Take this convex hull algorithm I&rsquo;d written:
vector&lt;Point&gt; find_convex_hull(const vector&lt;Point&gt;&amp; points) { vector&lt;Point&gt; hull; for (size_t i = 0; i &lt; points.size(); ++i) { for (size_t j = 0; j &lt; points.size(); ++j) { if (i == j) continue; bool all_on_same_side = true; for (size_t k = 0; k &lt; points.size(); ++k) { if (k == i || k == j) continue; if (!is_on_same_side(points[i], points[j], points[k])) { all_on_same_side = false; break; } } if (all_on_same_side) { hull.push_back(points[i]); hull.push_back(points[j]); } } } return remove_duplicates(hull); } Three nested loops! But with functional thinking, I saw predicate logic:
A point pair (i,j) belongs to the convex hull boundary if and only if all other points are on the same side of the line segment (i,j).
Mathematically: (i,j)‚ààhull‚ÄÖ‚ü∫‚ÄÖ‚àÄk‚â†i,j:same_side(i,j,k) (i,j) \\in \\text{hull} \\iff \\forall k \\neq i,j : \\text{same\\_side}(i,j,k) (i,j)‚ààhull‚ü∫‚àÄkÓÄ†=i,j:same_side(i,j,k)In C++, this becomes:
vector&lt;Point&gt; find_convex_hull_fp(const vector&lt;Point&gt;&amp; points) { auto pairs = cartesian_product(points, points); auto is_hull_edge = [&amp;](const pair&lt;Point, Point&gt;&amp; edge) { return all_of(points.begin(), points.end(), [&amp;](const Point&amp; p) { return &amp;p == &amp;edge.first || &amp;p == &amp;edge.second || is_on_same_side(edge.first, edge.second, p); }); }; return filter(pairs, is_hull_edge) | transform([](auto&amp;&amp; p) { return vector{p.first, p.second}; }) | flatten() | unique(); } Why This Matters: You Can Actually Prove Things Here&rsquo;s the cool part: functional code is easier to reason about.
With the original code, proving correctness meant:
Tracking three loop variables Understanding when the break happens Verifying when hull gets updated With the functional version:
cartesian_product generates all point pairs (obvious) is_hull_edge is a direct translation of the mathematical definition The composition uses standard, well-understood operations I can even write tests that verify mathematical properties:
// Convex hull property: all points should be inside the hull TEST(ConvexHull, AllPointsInsideHull) { auto points = generate_random_points(100); auto hull = find_convex_hull_fp(points); for (const auto&amp; p : points) { ASSERT_TRUE(is_point_inside_convex_polygon(p, hull)); } } Category Theory Sneaks In Recently, I was writing a config parser with multiple operations that could fail:
optional&lt;int&gt; parse_timeout(const string&amp; str); optional&lt;string&gt; parse_hostname(const string&amp; str); optional&lt;Config&gt; create_config(int timeout, const string&amp; host); The traditional way:
optional&lt;Config&gt; parse_config(const string&amp; timeout_str, const string&amp; host_str) { auto timeout = parse_timeout(timeout_str); if (!timeout) return nullopt; auto host = parse_hostname(host_str); if (!host) return nullopt; return create_config(*timeout, *host); } The functional way uses a pattern (some people call it a monad, but I just call it useful):
template&lt;typename T, typename Func&gt; auto and_then(const optional&lt;T&gt;&amp; opt, Func f) -&gt; decltype(f(opt.value())) { if (!opt) return decltype(f(opt.value()))(); return f(*opt); } optional&lt;Config&gt; parse_config_fp(const string&amp; timeout_str, const string&amp; host_str) { return and_then(parse_timeout(timeout_str), [&amp;](int timeout) { return and_then(parse_hostname(host_str), [&amp;](const string&amp; host) { return create_config(timeout, host); }); }); } Mathematically, this is composition in the Kleisli category: f:A‚ÜíM(B),g:B‚ÜíM(C)g‚àòKf:A‚ÜíM(C) f: A \\to M(B), \\quad g: B \\to M(C) \\\\ g \\circ_K f: A \\to M(C) f:A‚ÜíM(B),g:B‚ÜíM(C)g‚àòK‚Äãf:A‚ÜíM(C)Performance? Actually Better People say functional code is slow. Modern C++ compilers are smart:
// Hand-written &#34;optimized&#34; version double sum_squares(const vector&lt;double&gt;&amp; data) { double sum = 0.0; for (const auto&amp; x : data) { sum += x * x; } return sum; } // Functional version double sum_squares_fp(const vector&lt;double&gt;&amp; data) { return fold(data, 0.0, [](double acc, double x) { return acc + x * x; }); } With -O3, GCC generates identical assembly for both. The functional version is actually safer‚Äîno loop variables, no bounds checking worries.
My New Toolkit Here&rsquo;s what functional thinking added to my C++ toolbox:
map/filter/reduce - The basics for working with collections Function composition - compose(f, g)(x) = f(g(x)) Currying - curry(f)(a)(b) = f(a, b) Lazy evaluation - Using generator or ranges::view Like currying for configuration:
auto create_server = curry([](int port, const string&amp; host, Config config) { return Server{port, host, config}; }); auto create_local_server = create_server(8080, &#34;localhost&#34;); auto server = create_local_server(config); The Mindset Shift Functional programming taught me something important: code is math, and the compiler is my proof assistant.
Before: I wrote loops thinking &ldquo;do this repeatedly&rdquo;. Now: I write fold thinking &ldquo;apply this associative operation&rdquo;.
Before: I wrote conditionals thinking &ldquo;if this, then that&rdquo;. Now: I write filter thinking &ldquo;select elements satisfying this predicate&rdquo;.
This mindset lets me write code that&rsquo;s easier to prove correct. Last week I found a bug and mentally traced it:
Given: filter(is_even, [1,2,3,4]) = [2,4] Given: map(square, [2,4]) = [4,16] Given: fold(add, 0, [4,16]) = 20 Therefore: sum of squares of even numbers = 20 Writing it down like that was the proof.
Functional C++ in the Real World This is how I write production code now:
// HTTP request processing pipeline auto handle_request = compose( validate_request, authenticate, parse_body&lt;Order&gt;, process_order, create_response ); // Or with ranges auto valid_orders = requests | views::filter(is_valid_order) | views::transform(parse_order) | views::filter([](const Order&amp; o) { return o.total &gt; 100.0; }) | views::transform(apply_discount) | ranges::to&lt;vector&gt;(); This isn&rsquo;t &ldquo;functional C++&quot;‚Äîit&rsquo;s just C++. But it&rsquo;s C++ written with functional thinking.
Finally When I started seeing loops through mathematical eyes, they stopped being loops and became instances of algebraic structures. That perspective lets me write code that&rsquo;s cleaner, more correct, and honestly more fun to write.
Maybe that&rsquo;s the end goal of programming: code stops being instructions and becomes executable mathematics.
`,url:"https://www.functor.me/posts/thought_fp/"},"https://www.functor.me/tags/color-science/":{title:"Color-Science",tags:[],content:"",url:"https://www.functor.me/tags/color-science/"},"https://www.functor.me/tags/neovim/":{title:"Neovim",tags:[],content:"",url:"https://www.functor.me/tags/neovim/"},"https://www.functor.me/tags/oklab/":{title:"Oklab",tags:[],content:"",url:"https://www.functor.me/tags/oklab/"},"https://www.functor.me/tags/":{title:"Tags",tags:[],content:"",url:"https://www.functor.me/tags/"},"https://www.functor.me/posts/colorscheme/":{title:"The Best Theme Isn't the Prettiest‚ÄîIt's the One You Forget Exists",tags:["neovim","color-science","vision-research","oklab"],content:`For years, I was stuck in this cycle: find something that looks decent, tweak HSL values until it &ldquo;feels right,&rdquo; use it for a few weeks, then get that creeping eye strain. Suddenly colors that looked fine before would start to irritate me. Back to the drawing board.
I must have done this dozens of times. Each round felt more arbitrary than the last‚Äîjust moving sliders around hoping something would click. Honestly, it was getting ridiculous. Why couldn&rsquo;t I just find something that worked and stick with it?
Then one night, while adjusting my umpteenth orange hue, it hit me: people have been studying vision for decades. There&rsquo;s actual science about how we see color, what causes eye strain, how to make things readable. Maybe instead of guessing, I could actually, you know, use that science.
So I did. And it turns out, building a theme from first principles works way better than tweaking hex codes.
Part 1: Your Color Picker is Probably Lying to You Here&rsquo;s the thing no one tells you: RGB and HSL are kind of broken for designing themes. They make sense to computers but not to human eyes. In RGB, the &ldquo;distance&rdquo; between colors has nothing to do with how different they actually look. HSL is slightly better, but still weird‚Äîchanging saturation can make some colors get much brighter while others barely change.
It&rsquo;s like trying to measure temperature with a ruler. You&rsquo;re using the wrong tool for the job.
Enter Oklab: A Color Space That Actually Makes Sense After digging around, I found something called Oklab. It&rsquo;s a &ldquo;perceptually uniform&rdquo; color space, which is a fancy way of saying: if you move a color 10 units in Oklab, it looks about 10 units different to your eyes. No surprises.
The math goes something like this:
Step 1: Oklab ‚Üí LMS (how your eye&rsquo;s cones respond) [lms]=[10.39630.21581‚àí0.1056‚àí0.06391‚àí0.0895‚àí1.2915][Lab] \\begin{bmatrix} l \\\\ m \\\\ s \\end{bmatrix} = \\begin{bmatrix} 1 &amp; 0.3963 &amp; 0.2158 \\\\ 1 &amp; -0.1056 &amp; -0.0639 \\\\ 1 &amp; -0.0895 &amp; -1.2915 \\end{bmatrix} \\begin{bmatrix} L \\\\ a \\\\ b \\end{bmatrix} ‚Äãlms‚Äã‚Äã=‚Äã111‚Äã0.3963‚àí0.1056‚àí0.0895‚Äã0.2158‚àí0.0639‚àí1.2915‚Äã‚Äã‚ÄãLab‚Äã‚ÄãStep 2: Inverse cube root LMSlinear=[l3,m3,s3]T \\text{LMS}_{\\text{linear}} = [l^3, m^3, s^3]^T LMSlinear‚Äã=[l3,m3,s3]TStep 3: LMS ‚Üí Linear RGB [RGB]=[4.0767‚àí3.30770.2310‚àí1.26842.6098‚àí0.3413‚àí0.0042‚àí0.70341.7076][l3m3s3] \\begin{bmatrix} R \\\\ G \\\\ B \\end{bmatrix} = \\begin{bmatrix} 4.0767 &amp; -3.3077 &amp; 0.2310 \\\\ -1.2684 &amp; 2.6098 &amp; -0.3413 \\\\ -0.0042 &amp; -0.7034 &amp; 1.7076 \\end{bmatrix} \\begin{bmatrix} l^3 \\\\ m^3 \\\\ s^3 \\end{bmatrix} ‚ÄãRGB‚Äã‚Äã=‚Äã4.0767‚àí1.2684‚àí0.0042‚Äã‚àí3.30772.6098‚àí0.7034‚Äã0.2310‚àí0.34131.7076‚Äã‚Äã‚Äãl3m3s3‚Äã‚ÄãStep 4: Gamma correction (sRGB) CsRGB={12.92√óClinearif¬†Clinear‚â§0.00313081.055√óClinear1/2.4‚àí0.055otherwise C_{\\text{sRGB}} = \\begin{cases} 12.92 \\times C_{\\text{linear}} &amp; \\text{if } C_{\\text{linear}} \\leq 0.0031308 \\\\ 1.055 \\times C_{\\text{linear}}^{1/2.4} - 0.055 &amp; \\text{otherwise} \\end{cases} CsRGB‚Äã={12.92√óClinear‚Äã1.055√óClinear1/2.4‚Äã‚àí0.055‚Äãif¬†Clinear‚Äã‚â§0.0031308otherwise‚ÄãYeah, that looks intimidating. But here&rsquo;s the Lua code that makes it usable:
local function oklab_to_linear_rgb(L, a, b) -- Oklab to LMS local l = L + 0.3963377774 * a + 0.2158037573 * b local m = L - 0.1055613458 * a - 0.0638541728 * b local s = L - 0.0894841775 * a - 1.2914855480 * b -- Inverse cube root local l3, m3, s3 = l * l * l, m * m * m, s * s * s -- LMS to linear RGB local r = 4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3 local g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3 local b_out = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3 return r, g, b_out end local function linear_to_srgb_component(c) -- Gamma correction if c &lt;= 0.0031308 then return c * 12.92 else return 1.055 * (c ^ (1 / 2.4)) - 0.055 end end local function oklab_to_srgb(L, a, b) local r, g, b_comp = oklab_to_linear_rgb(L, a, b) r = linear_to_srgb_component(r) g = linear_to_srgb_component(g) b_comp = linear_to_srgb_component(b_comp) -- Clamp and convert to hex r = math.floor(math.max(0, math.min(1, r)) * 255 + 0.5) g = math.floor(math.max(0, math.min(1, g)) * 255 + 0.5) b_comp = math.floor(math.max(0, math.min(1, b_comp)) * 255 + 0.5) return string.format(&#39;#%02x%02x%02x&#39;, r, g, b_comp) end The cool part? Now instead of this:
-- Random hex code I found somewhere local orange = &#34;#c5895b&#34; I can do this:
-- &#34;I want a color that&#39;s 68% bright, slightly warm&#34; local orange = oklab_to_srgb(0.68, 0.055, 0.065) That first number is brightness (0-1). The next two control hue and saturation. Want it brighter? Increase the first number. Want it more orange? Adjust the ratio. It&rsquo;s predictable in a way hex codes never were.
Part 2: What Actually Needs to be Colorful? Here&rsquo;s where I made my first big mistake. I used to color everything‚Äîvariables, operators, you name it. Turns out, that&rsquo;s probably wrong.
I found this 2018 study with 390 programming beginners. The surprising finding? Syntax highlighting doesn&rsquo;t really help with understanding code. But wait‚Äîit does help when it emphasizes structural elements rather than coloring everything equally.
The takeaway: Highlight structure, not noise.
Then I read Ivan Tonsky&rsquo;s article where he points out that most of your code is variables and function calls. If you highlight all of those, you&rsquo;re coloring like 75% of the screen. No wonder everything looks busy!
His suggestion made so much sense: keep variables and operators neutral (same color as regular text). Only use bright colors for the stuff that actually matters.
My New Three-Tier System This research led me to a much simpler approach:
Bright colors for the important bits:
Control flow (if, for, while, return) Function definitions Type declarations Regular text color for the rest:
Variable names Operators Function parameters Dimmed colors for secondary stuff:
Comments Delimiters The result is subtle but effective. The code&rsquo;s structure jumps out at you, but most of the screen stays calm and readable.
Part 3: Brightness is Everything (Seriously) This was my biggest &ldquo;aha&rdquo; moment. I used to spend hours debating whether keywords should be orange or yellow. Turns out, I was asking the wrong question.
Human eyes are way more sensitive to brightness differences than to color differences. Like, 5-10 times more sensitive. There&rsquo;s actual science behind this called the &ldquo;Contrast Sensitivity Function.&rdquo;
So the real question isn&rsquo;t &ldquo;what color should this be?&rdquo; It&rsquo;s &ldquo;how bright should this be compared to that?&rdquo;
Building a Brightness Hierarchy That Actually Works I started with some basic constraints:
Background: L=0.24 (dark enough to be comfortable at night) Regular text: L=0.74 (great contrast, meets accessibility standards) From the research, I knew structure was most important, errors needed attention, and data was secondary. So I made three brightness levels:
Brightest (L=0.68): Structure elements (keywords, functions, types) Middle (L=0.66): Errors and warnings Dimmest (L=0.64): Data (strings, numbers, constants) The math checks out for contrast ratios: CR(L1,Lbg)=0.68+0.050.24+0.05=5.52:1CR(L2,Lbg)=0.66+0.050.24+0.05=5.03:1CR(L3,Lbg)=0.64+0.050.24+0.05=4.76:1 \\begin{aligned} \\text{CR}(L_1, L_{\\text{bg}}) &amp;= \\frac{0.68 + 0.05}{0.24 + 0.05} = 5.52:1 \\\\ \\text{CR}(L_2, L_{\\text{bg}}) &amp;= \\frac{0.66 + 0.05}{0.24 + 0.05} = 5.03:1 \\\\ \\text{CR}(L_3, L_{\\text{bg}}) &amp;= \\frac{0.64 + 0.05}{0.24 + 0.05} = 4.76:1 \\end{aligned} CR(L1‚Äã,Lbg‚Äã)CR(L2‚Äã,Lbg‚Äã)CR(L3‚Äã,Lbg‚Äã)‚Äã=0.24+0.050.68+0.05‚Äã=5.52:1=0.24+0.050.66+0.05‚Äã=5.03:1=0.24+0.050.64+0.05‚Äã=4.76:1‚ÄãAll three meet WCAG AA standards, and the brightness differences (ŒîL=0.02) are noticeable without being jarring.
Here&rsquo;s what&rsquo;s cool: in my old themes, errors were the same brightness as strings. No wonder I&rsquo;d miss them! Now errors stand out just enough to catch my attention without looking like an alarm went off.
The Complete Brightness System Level Brightness Use For Why It Works 1 L=0.68 Keywords, Functions, Types Guides your eye to the code&rsquo;s structure 2 L=0.66 Errors, Warnings Noticeable but not overwhelming 3 L=0.64 Strings, Numbers, Constants Stays in the background - L=0.24 Background Easy on the eyes - L=0.74 Regular text Maximum readability Part 4: The Fatigue Factor Here&rsquo;s something I never considered: different colors actually cause different amounts of eye strain. Red wavelengths are the worst‚Äîthey make your pupils constrict more, which gets tiring. Yellow is the easiest on your eyes.
There&rsquo;s research (they measure pupil response and everything) that shows for comfortable long sessions, you want to keep colors muted:
Average saturation around 0.08 Red saturation under 0.09 Yellow/green under 0.10 In Oklab, saturation is simple: s=a2+b2 s = \\sqrt{a^2 + b^2} s=a2+b2‚ÄãSo I made sure all my colors stayed in the safe zone:
-- Orange for keywords: ‚àö(0.055¬≤ + 0.065¬≤) ‚âà 0.085 colors.orange = oklab_to_srgb(0.68, 0.055, 0.065) -- Red for errors: ‚àö(0.08¬≤ + 0.04¬≤) ‚âà 0.089 (just under 0.09) colors.red = oklab_to_srgb(0.66, 0.08, 0.04) -- Yellow for types: ‚àö(0.0¬≤ + 0.08¬≤) ‚âà 0.08 colors.yellow = oklab_to_srgb(0.68, 0.0, 0.08) No more wondering why my eyes hurt after a marathon coding session.
Part 5: What Colors &ldquo;Mean&rdquo; Colors aren&rsquo;t just pretty‚Äîthey carry associations. Research shows we tend to agree on what colors mean:
Red ‚Üí Error, Danger, Stop Orange ‚Üí Action, Warning, Warm Yellow ‚Üí Important, Attention Green ‚Üí Success, Natural, Content Blue ‚Üí Logic, Stability, Cool Cyan ‚Üí Technical, Meta Violet ‚Üí Abstract, Special This gave me a logical way to assign colors:
Code Element Why This Color Oklab Values Keywords Action ‚Üí Orange (0.68, 0.055, 0.065) Functions Logic ‚Üí Blue (0.68, -0.02, -0.06) Types Important ‚Üí Yellow (0.68, 0.02, 0.08) Errors Danger ‚Üí Red (0.66, 0.08, 0.04) Strings Content ‚Üí Green (0.64, -0.05, 0.06) Constants Technical ‚Üí Cyan (0.64, -0.055, -0.01) Numbers Abstract ‚Üí Violet (0.64, 0.05, -0.04) Putting It All Together Here&rsquo;s the final palette. Every value comes from those principles, not random guesses:
local colors = {} -- Background and text colors.bg = oklab_to_srgb(0.24, 0.001, 0.006) colors.fg = oklab_to_srgb(0.74, 0.0, 0.008) -- Layer 1: Structure (brightest) colors.orange = oklab_to_srgb(0.68, 0.055, 0.065) -- Keywords colors.blue = oklab_to_srgb(0.68, -0.02, -0.06) -- Functions colors.yellow = oklab_to_srgb(0.68, 0.0, 0.08) -- Types -- Layer 2: Diagnostics colors.red = oklab_to_srgb(0.66, 0.08, 0.04) -- Errors -- Layer 3: Data colors.green = oklab_to_srgb(0.64, -0.05, 0.06) -- Strings colors.cyan = oklab_to_srgb(0.64, -0.055, -0.01) -- Constants colors.violet = oklab_to_srgb(0.64, 0.05, -0.04) -- Numbers return colors And the highlight groups:
-- Important stuff (bright) vim.api.nvim_set_hl(0, &#39;Keyword&#39;, { fg = colors.orange }) vim.api.nvim_set_hl(0, &#39;Function&#39;, { fg = colors.blue }) vim.api.nvim_set_hl(0, &#39;Type&#39;, { fg = colors.yellow }) -- Less important (dimmer) vim.api.nvim_set_hl(0, &#39;String&#39;, { fg = colors.green }) vim.api.nvim_set_hl(0, &#39;Constant&#39;, { fg = colors.cyan }) vim.api.nvim_set_hl(0, &#39;Number&#39;, { fg = colors.violet }) -- Neutral (same as regular text) vim.api.nvim_set_hl(0, &#39;Identifier&#39;, { fg = colors.fg }) -- Variables vim.api.nvim_set_hl(0, &#39;Operator&#39;, { fg = colors.fg }) -- =, +, -, etc. Does It Actually Work? Don&rsquo;t doubt it, this is still neovim üòè. I&rsquo;ve been using this theme (I call it Retina) for two months now. Here&rsquo;s what I&rsquo;ve noticed:
My eyes don&rsquo;t get tired anymore. I can code for hours without that strained feeling. Errors actually stand out. That slight brightness bump makes all the difference. I can see the code&rsquo;s structure immediately. My eyes naturally follow the bright keywords. It&rsquo;s&hellip; quiet. With most variables staying neutral, there&rsquo;s way less visual noise. A Quick Reality Check Look, vision is personal. This works for me, but your eyes might be different. Things that matter:
Your age (older eyes often need more contrast) Your monitor (OLED vs LCD, different calibrations) Your environment (dark room vs bright office) Your color vision (about 8% of men see colors differently) The beauty of this approach is you can adjust the parameters instead of guessing:
-- Need more contrast? Bump up the brightness: colors.orange = oklab_to_srgb(0.70, 0.055, 0.065) -- Was 0.68 -- Colors too strong? Tone down the saturation: colors.orange = oklab_to_srgb(0.68, 0.044, 0.052) -- 20% less saturation -- Want different hues? Adjust the a,b ratio: colors.orange = oklab_to_srgb(0.68, 0.050, 0.070) -- More yellow You&rsquo;re tuning a system, not just picking random colors.
The best theme really is the one you forget you&rsquo;re using. It just gets out of your way and lets you focus on the code.
References &amp; Further Reading Oklab color space: https://bottosson.github.io/posts/oklab/ Contrast Sensitivity Function: Barten, P. G. J. (1999) Color Appearance Models: Fairchild, M. D. (2013) Visual Fatigue Study: Fan et al. (2024) Color Semantics: Schloss, K. B. (2024) Vision and Aging: Owsley, C. (2016) Syntax Highlighting Research: Hannebauer et al. (2018) &ldquo;Syntax Highlighting is a Waste of Time&rdquo;: https://tonsky.me/blog/syntax-highlighting/ You can find the complete theme on GitHub. Use it, tweak it, or just steal the ideas for your own theme. Either way, I hope it helps you break out of the endless theme-tweaking cycle.
`,url:"https://www.functor.me/posts/colorscheme/"},"https://www.functor.me/tags/vision-research/":{title:"Vision-Research",tags:[],content:"",url:"https://www.functor.me/tags/vision-research/"},"https://www.functor.me/categories/":{title:"Categories",tags:[],content:"",url:"https://www.functor.me/categories/"}}</script></footer></body></html>