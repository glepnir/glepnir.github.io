<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png }><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content="Posts"><link rel=alternate type=application/rss+xml href=https://www.functor.me/posts/index.xml title="glepnir's blog"><title>Posts | glepnir's blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.0e9c0bb0a7de7a330263937778a4d7c0d0c6be7f327c69a0223c9f2fd31e00d5.css media=all></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/><u>H</u>ome</a></li><li><a tabindex=-1 class=menu-link href=/tags><u>T</u>ags</a></li></ul></nav><div class=home-content></div><h2 class=section-title>Posts</h2><ul class=post-list><li><div style="display:grid;grid-template-columns:7em auto"><span class=date>Dec 27, 2025</span>
<a href=/posts/thought_fp/>When Loops Become Math: How Functional Thinking Changed My C++</a></div></li><li><div style="display:grid;grid-template-columns:7em auto"><span class=date>Dec 24, 2025</span>
<a href=/posts/oklab_design/>Stop Guessing Hex Codes: A Better Way to Pick Theme Colors</a></div></li></ul><br><footer class=site-footer><p class=footer-meta>Â© 2025 glepnir Â·
<a href=https://github.com/glepnir>GitHub</a> Â·
<a href=https://reddit.com/u/glephunter>Reddit</a> Â·
<a href=https://www.functor.me/index.xml>RSS</a></p><script defer>document.addEventListener("keydown",function(e){if(document.activeElement.isContentEditable)return!1;if(document.activeElement.tagName=="INPUT")return!1;if(e.altKey||e.ctrlKey||e.shiftKey)return!1;var t=e.key;if(t==="h")e.preventDefault(),e.stopPropagation(),window.location.href="/";else if(t==="t")e.preventDefault(),e.stopPropagation(),window.location.href=`https://${location.hostname}/tags`;else if(t==="i"){e.preventDefault(),e.stopPropagation();const t=document.querySelectorAll("input");for(let e=0;e<t.length;e++)if(t[e].offsetParent!==null){t[e].selectionStart=t[e].selectionEnd=t[e].value.length,t[e].focus();break}}return!1})</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,200))}setTimeout(scrollHandler,100)</script><script defer>function getTextContentRecursively(e){let t="";if(e.nodeType===Node.TEXT_NODE)return e.textContent||"";for(const n of e.childNodes)t+=getTextContentRecursively(n);return t}function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]:not(.output):not([class*="language-console"])');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const n=getTextContentRecursively(e);navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script>window.store={"https://www.functor.me/":{title:"glepnir's blog",tags:[],content:"",url:"https://www.functor.me/"},"https://www.functor.me/posts/":{title:"Posts",tags:[],content:"",url:"https://www.functor.me/posts/"},"https://www.functor.me/posts/thought_fp/":{title:"When Loops Become Math: How Functional Thinking Changed My C++",tags:[],content:`Last week, I was staring at two pieces of code a friend had sent me, asking which one I preferred. They looked like this:
// Version A double calculate_mean(const vector&lt;double&gt;&amp; data) { double sum = 0.0; for (const auto&amp; x : data) { sum += x; } return sum / data.size(); } // Version B double calculate_stddev(const vector&lt;double&gt;&amp; data) { double sum = 0.0; double mean = calculate_mean(data); for (const auto&amp; x : data) { sum += (x - mean) * (x - mean); } return sqrt(sum / data.size()); } I looked at them for a solid five seconds before it hit me: these two loops were fundamentally the same mathematical pattern! But in the code, that pattern was buried under for loops and accumulation variables.
Seeing with Math Eyes In math, we&rsquo;d write these calculations as:
mean=1nâˆ‘i=1nxi \\text{mean} = \\frac{1}{n} \\sum_{i=1}^n x_i mean=n1â€‹i=1âˆ‘nâ€‹xiâ€‹stddev=1nâˆ‘i=1n(xiâˆ’Î¼)2 \\text{stddev} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2} stddev=n1â€‹i=1âˆ‘nâ€‹(xiâ€‹âˆ’Î¼)2â€‹See that $\\sum$ symbol? That&rsquo;s our abstraction point. In functional programming, this is called a fold (or reduce), defined as:
fold(f,z,[x1,x2,...,xn])=f(f(f(z,x1),x2),...,xn) \\text{fold}(f, z, [x_1, x_2, ..., x_n]) = f(f(f(z, x_1), x_2), ..., x_n) fold(f,z,[x1â€‹,x2â€‹,...,xnâ€‹])=f(f(f(z,x1â€‹),x2â€‹),...,xnâ€‹)Looking at my code with this new perspective:
template&lt;typename T, typename BinaryOp&gt; T fold(const vector&lt;T&gt;&amp; vec, T init, BinaryOp op) { T result = init; for (const auto&amp; x : vec) { result = op(result, x); } return result; } Now both calculations become:
double mean = fold(data, 0.0, plus&lt;double&gt;{}) / data.size(); double variance = fold(data, 0.0, [mean](double acc, double x) { return acc + (x - mean) * (x - mean); }) / data.size(); The Real Breakthrough: Seeing Deeper Patterns I started noticing this pattern everywhere. Take this convex hull algorithm I&rsquo;d written:
vector&lt;Point&gt; find_convex_hull(const vector&lt;Point&gt;&amp; points) { vector&lt;Point&gt; hull; for (size_t i = 0; i &lt; points.size(); ++i) { for (size_t j = 0; j &lt; points.size(); ++j) { if (i == j) continue; bool all_on_same_side = true; for (size_t k = 0; k &lt; points.size(); ++k) { if (k == i || k == j) continue; if (!is_on_same_side(points[i], points[j], points[k])) { all_on_same_side = false; break; } } if (all_on_same_side) { hull.push_back(points[i]); hull.push_back(points[j]); } } } return remove_duplicates(hull); } Three nested loops! But with functional thinking, I saw predicate logic:
A point pair (i,j) belongs to the convex hull boundary if and only if all other points are on the same side of the line segment (i,j).
Mathematically: (i,j)âˆˆhullâ€…âŸºâ€…âˆ€kâ‰ i,j:same_side(i,j,k) (i,j) \\in \\text{hull} \\iff \\forall k \\neq i,j : \\text{same\\_side}(i,j,k) (i,j)âˆˆhullâŸºâˆ€kî€ =i,j:same_side(i,j,k)In C++, this becomes:
vector&lt;Point&gt; find_convex_hull_fp(const vector&lt;Point&gt;&amp; points) { auto pairs = cartesian_product(points, points); auto is_hull_edge = [&amp;](const pair&lt;Point, Point&gt;&amp; edge) { return all_of(points.begin(), points.end(), [&amp;](const Point&amp; p) { return &amp;p == &amp;edge.first || &amp;p == &amp;edge.second || is_on_same_side(edge.first, edge.second, p); }); }; return filter(pairs, is_hull_edge) | transform([](auto&amp;&amp; p) { return vector{p.first, p.second}; }) | flatten() | unique(); } Why This Matters: You Can Actually Prove Things Here&rsquo;s the cool part: functional code is easier to reason about.
With the original code, proving correctness meant:
Tracking three loop variables Understanding when the break happens Verifying when hull gets updated With the functional version:
cartesian_product generates all point pairs (obvious) is_hull_edge is a direct translation of the mathematical definition The composition uses standard, well-understood operations I can even write tests that verify mathematical properties:
// Convex hull property: all points should be inside the hull TEST(ConvexHull, AllPointsInsideHull) { auto points = generate_random_points(100); auto hull = find_convex_hull_fp(points); for (const auto&amp; p : points) { ASSERT_TRUE(is_point_inside_convex_polygon(p, hull)); } } Category Theory Sneaks In Recently, I was writing a config parser with multiple operations that could fail:
optional&lt;int&gt; parse_timeout(const string&amp; str); optional&lt;string&gt; parse_hostname(const string&amp; str); optional&lt;Config&gt; create_config(int timeout, const string&amp; host); The traditional way:
optional&lt;Config&gt; parse_config(const string&amp; timeout_str, const string&amp; host_str) { auto timeout = parse_timeout(timeout_str); if (!timeout) return nullopt; auto host = parse_hostname(host_str); if (!host) return nullopt; return create_config(*timeout, *host); } The functional way uses a pattern (some people call it a monad, but I just call it useful):
template&lt;typename T, typename Func&gt; auto and_then(const optional&lt;T&gt;&amp; opt, Func f) -&gt; decltype(f(opt.value())) { if (!opt) return decltype(f(opt.value()))(); return f(*opt); } optional&lt;Config&gt; parse_config_fp(const string&amp; timeout_str, const string&amp; host_str) { return and_then(parse_timeout(timeout_str), [&amp;](int timeout) { return and_then(parse_hostname(host_str), [&amp;](const string&amp; host) { return create_config(timeout, host); }); }); } Mathematically, this is composition in the Kleisli category: f:Aâ†’M(B),g:Bâ†’M(C)gâˆ˜Kf:Aâ†’M(C) f: A \\to M(B), \\quad g: B \\to M(C) \\\\ g \\circ_K f: A \\to M(C) f:Aâ†’M(B),g:Bâ†’M(C)gâˆ˜Kâ€‹f:Aâ†’M(C)Performance? Actually Better People say functional code is slow. Modern C++ compilers are smart:
// Hand-written &#34;optimized&#34; version double sum_squares(const vector&lt;double&gt;&amp; data) { double sum = 0.0; for (const auto&amp; x : data) { sum += x * x; } return sum; } // Functional version double sum_squares_fp(const vector&lt;double&gt;&amp; data) { return fold(data, 0.0, [](double acc, double x) { return acc + x * x; }); } With -O3, GCC generates identical assembly for both. The functional version is actually saferâ€”no loop variables, no bounds checking worries.
My New Toolkit Here&rsquo;s what functional thinking added to my C++ toolbox:
map/filter/reduce - The basics for working with collections Function composition - compose(f, g)(x) = f(g(x)) Currying - curry(f)(a)(b) = f(a, b) Lazy evaluation - Using generator or ranges::view Like currying for configuration:
auto create_server = curry([](int port, const string&amp; host, Config config) { return Server{port, host, config}; }); auto create_local_server = create_server(8080, &#34;localhost&#34;); auto server = create_local_server(config); The Mindset Shift Functional programming taught me something important: code is math, and the compiler is my proof assistant.
Before: I wrote loops thinking &ldquo;do this repeatedly&rdquo;. Now: I write fold thinking &ldquo;apply this associative operation&rdquo;.
Before: I wrote conditionals thinking &ldquo;if this, then that&rdquo;. Now: I write filter thinking &ldquo;select elements satisfying this predicate&rdquo;.
This mindset lets me write code that&rsquo;s easier to prove correct. Last week I found a bug and mentally traced it:
Given: filter(is_even, [1,2,3,4]) = [2,4] Given: map(square, [2,4]) = [4,16] Given: fold(add, 0, [4,16]) = 20 Therefore: sum of squares of even numbers = 20 Writing it down like that was the proof.
Functional C++ in the Real World This is how I write production code now:
// HTTP request processing pipeline auto handle_request = compose( validate_request, authenticate, parse_body&lt;Order&gt;, process_order, create_response ); // Or with ranges auto valid_orders = requests | views::filter(is_valid_order) | views::transform(parse_order) | views::filter([](const Order&amp; o) { return o.total &gt; 100.0; }) | views::transform(apply_discount) | ranges::to&lt;vector&gt;(); This isn&rsquo;t &ldquo;functional C++&quot;â€”it&rsquo;s just C++. But it&rsquo;s C++ written with functional thinking.
Finally When I started seeing loops through mathematical eyes, they stopped being loops and became instances of algebraic structures. That perspective lets me write code that&rsquo;s cleaner, more correct, and honestly more fun to write.
Maybe that&rsquo;s the end goal of programming: code stops being instructions and becomes executable mathematics.
`,url:"https://www.functor.me/posts/thought_fp/"},"https://www.functor.me/tags/color-theory/":{title:"Color-Theory",tags:[],content:"",url:"https://www.functor.me/tags/color-theory/"},"https://www.functor.me/tags/neovim/":{title:"Neovim",tags:[],content:"",url:"https://www.functor.me/tags/neovim/"},"https://www.functor.me/tags/oklab/":{title:"Oklab",tags:[],content:"",url:"https://www.functor.me/tags/oklab/"},"https://www.functor.me/posts/oklab_design/":{title:"Stop Guessing Hex Codes: A Better Way to Pick Theme Colors",tags:["neovim","oklab","color-theory"],content:`I&rsquo;ve probably made some different Neovim themes over the years. Each time I thought &ldquo;this is the one&rdquo; and each time, a month later, I&rsquo;d be tweaking colors again because something just felt&hellip; off.
The problem? I was doing what everyone doesâ€”picking colors by eye, converting between RGB and HSL, hoping the math would somehow make sense. Spoiler: it doesn&rsquo;t.
Then I found Oklab and everything got way easier.
RGB/HSL Are Kinda Broken for This Here&rsquo;s the thing: in RGB, changing red from 200 to 210 might look like a tiny shift, but changing blue from 200 to 210 could be a massive difference. HSL is better but still weirdâ€”adjusting saturation can make some colors way brighter and others barely change.
You end up with this:
-- Wait, which one is brighter? ðŸ¤· local color1 = &#34;#c5895b&#34; local color2 = &#34;#a87d52&#34; No idea without actually looking at them. And if you want to make color1 &ldquo;just a bit dimmer&rdquo;? Good luck.
Enter Oklab: Colors That Actually Make Sense Oklab is a &ldquo;perceptually uniform&rdquo; color space. Translation: move a color 0.1 units and it looks 0.1 units different. Predictably.
It has three channels:
L (0-1): Brightness. 0 = black, 1 = white, simple. a (-0.4 to +0.4): Red â†” Green b (-0.4 to +0.4): Yellow â†” Blue Want an orange that&rsquo;s 68% bright? Easy:
oklab_to_srgb(0.68, 0.055, 0.065) -- L=0.68, slightly red, slightly yellow = orange Want it brighter? Change the first number:
oklab_to_srgb(0.72, 0.055, 0.065) -- Same hue, 4% brighter That&rsquo;s it. No guessing.
Implementation The conversion from Oklab to RGB goes through a few steps:
Step 1: Oklab â†’ LMS (cone response) [lms]=[10.39630.21581âˆ’0.1056âˆ’0.06391âˆ’0.0895âˆ’1.2915][Lab] \\begin{bmatrix} l \\\\ m \\\\ s \\end{bmatrix} = \\begin{bmatrix} 1 &amp; 0.3963 &amp; 0.2158 \\\\ 1 &amp; -0.1056 &amp; -0.0639 \\\\ 1 &amp; -0.0895 &amp; -1.2915 \\end{bmatrix} \\begin{bmatrix} L \\\\ a \\\\ b \\end{bmatrix} â€‹lmsâ€‹â€‹=â€‹111â€‹0.3963âˆ’0.1056âˆ’0.0895â€‹0.2158âˆ’0.0639âˆ’1.2915â€‹â€‹â€‹Labâ€‹â€‹Step 2: Inverse cube root LMSlinear=[l3,m3,s3]T \\text{LMS}_{\\text{linear}} = [l^3, m^3, s^3]^T LMSlinearâ€‹=[l3,m3,s3]TStep 3: LMS â†’ Linear RGB [RGB]=[4.0767âˆ’3.30770.2310âˆ’1.26842.6098âˆ’0.3413âˆ’0.0042âˆ’0.70341.7076][l3m3s3] \\begin{bmatrix} R \\\\ G \\\\ B \\end{bmatrix} = \\begin{bmatrix} 4.0767 &amp; -3.3077 &amp; 0.2310 \\\\ -1.2684 &amp; 2.6098 &amp; -0.3413 \\\\ -0.0042 &amp; -0.7034 &amp; 1.7076 \\end{bmatrix} \\begin{bmatrix} l^3 \\\\ m^3 \\\\ s^3 \\end{bmatrix} â€‹RGBâ€‹â€‹=â€‹4.0767âˆ’1.2684âˆ’0.0042â€‹âˆ’3.30772.6098âˆ’0.7034â€‹0.2310âˆ’0.34131.7076â€‹â€‹â€‹l3m3s3â€‹â€‹Step 4: Gamma correction (sRGB) CsRGB={12.92Ã—ClinearifÂ Clinearâ‰¤0.00313081.055Ã—Clinear1/2.4âˆ’0.055otherwise C_{\\text{sRGB}} = \\begin{cases} 12.92 \\times C_{\\text{linear}} &amp; \\text{if } C_{\\text{linear}} \\leq 0.0031308 \\\\ 1.055 \\times C_{\\text{linear}}^{1/2.4} - 0.055 &amp; \\text{otherwise} \\end{cases} CsRGBâ€‹={12.92Ã—Clinearâ€‹1.055Ã—Clinear1/2.4â€‹âˆ’0.055â€‹ifÂ Clinearâ€‹â‰¤0.0031308otherwiseâ€‹Here&rsquo;s the implementation:
local function oklab_to_linear_rgb(L, a, b) -- Transform Oklab to LMS (cone response) local l = L + 0.3963377774 * a + 0.2158037573 * b local m = L - 0.1055613458 * a - 0.0638541728 * b local s = L - 0.0894841775 * a - 1.2914855480 * b -- Apply inverse cube root local l3, m3, s3 = l * l * l, m * m * m, s * s * s -- LMS to linear RGB local r = 4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3 local g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3 local b_out = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3 return r, g, b_out end local function linear_to_srgb_component(c) if c &lt;= 0.0031308 then return c * 12.92 else return 1.055 * (c ^ (1 / 2.4)) - 0.055 end end local function oklab_to_srgb(L, a, b) local r, g, b_comp = oklab_to_linear_rgb(L, a, b) r = linear_to_srgb_component(r) g = linear_to_srgb_component(g) b_comp = linear_to_srgb_component(b_comp) -- Convert to 8-bit and clamp r = math.floor(math.max(0, math.min(1, r)) * 255 + 0.5) g = math.floor(math.max(0, math.min(1, g)) * 255 + 0.5) b_comp = math.floor(math.max(0, math.min(1, b_comp)) * 255 + 0.5) return string.format(&#39;#%02x%02x%02x&#39;, r, g, b_comp) end Those magic numbers come from the Oklab spec. Just copy-paste and it works.
Designing a Palette Here&rsquo;s how I actually use this. Instead of random hex codes, I think in terms of brightness and hue.
Background and foreground first:
local colors = {} -- Dark but not pure black (L=0.24, basically neutral) colors.bg = oklab_to_srgb(0.24, 0.001, 0.006) -- Bright text (L=0.74, also basically neutral) colors.fg = oklab_to_srgb(0.74, 0.0, 0.008) Then decide on a brightness hierarchy.
There are two common approaches:
Style 1: Structure-First
Brighten keywords, functions, types - emphasize code structure Dim data (strings, numbers) - they&rsquo;re secondary Example: structure at L=0.68, data at L=0.64 Style 2: Data-First (Tonsky&rsquo;s philosophy)
Dim keywords (low brightness + low saturation) - they&rsquo;re just syntactic noise Brighten function definitions, strings, numbers - that&rsquo;s your actual code Example: keywords at L=0.60, data at L=0.68-0.70 How to Pick a/b Values (Hue) Here&rsquo;s a quick reference for common colors in Oklab space:
-- Red: a &gt; 0, b near 0 or slightly positive oklab_to_srgb(L, 0.08, 0.04) -- orange-red oklab_to_srgb(L, 0.10, 0.02) -- pure red oklab_to_srgb(L, 0.10, -0.02) -- magenta-red -- Orange: a &gt; 0, b &gt; 0, roughly equal oklab_to_srgb(L, 0.055, 0.065) -- typical orange oklab_to_srgb(L, 0.05, 0.07) -- more yellow-orange -- Yellow: a â‰ˆ 0, b &gt; 0 oklab_to_srgb(L, 0.02, 0.08) -- yellow-orange oklab_to_srgb(L, 0.0, 0.08) -- pure yellow oklab_to_srgb(L, -0.02, 0.08) -- yellow-green -- Green: a &lt; 0, b &gt; 0 oklab_to_srgb(L, -0.05, 0.06) -- typical green oklab_to_srgb(L, -0.08, 0.04) -- deeper green -- Cyan: a &lt; 0, b &lt; 0, |a| &gt; |b| oklab_to_srgb(L, -0.055, -0.01) -- cyan oklab_to_srgb(L, -0.06, -0.03) -- more blue-cyan -- Blue: a &lt; 0, b &lt; 0, |b| &gt; |a| oklab_to_srgb(L, -0.02, -0.06) -- typical blue oklab_to_srgb(L, -0.01, -0.08) -- deeper blue -- Violet/Purple: a &gt; 0, b &lt; 0 oklab_to_srgb(L, 0.05, -0.04) -- violet oklab_to_srgb(L, 0.08, -0.06) -- purple Saturation control: saturation=a2+b2\\text{saturation} = \\sqrt{a^2 + b^2}saturation=a2+b2â€‹
s &lt; 0.05: very muted, almost gray s â‰ˆ 0.08: moderate, comfortable for long sessions s &gt; 0.10: vivid, can be fatiguing So if you want a &ldquo;medium orange at 68% brightness with moderate saturation around 0.08&rdquo;:
-- Start with the hue ratio you want (orange â‰ˆ equal a and b) -- Then scale to get saturation â‰ˆ 0.08 local orange = oklab_to_srgb(0.68, 0.055, 0.065) -- sqrt(0.055Â² + 0.065Â²) â‰ˆ 0.085 Blending Colors Sometimes you need a subtle background colorâ€”like for diagnostic messages. You want it to be related to the error color but way more subtle.
Here&rsquo;s my blend function:
local function hex_to_rgb(hex) hex = hex:gsub(&#39;#&#39;, &#39;&#39;) return { tonumber(hex:sub(1, 2), 16), tonumber(hex:sub(3, 4), 16), tonumber(hex:sub(5, 6), 16), } end local function rgb_to_hex(c) return string.format(&#39;#%02x%02x%02x&#39;, c[1], c[2], c[3]) end local function blend(fg, bg, t) local a, b = hex_to_rgb(fg), hex_to_rgb(bg) local c = { math.floor(a[1] * (1 - t) + b[1] * t + 0.5), math.floor(a[2] * (1 - t) + b[2] * t + 0.5), math.floor(a[3] * (1 - t) + b[3] * t + 0.5), } return rgb_to_hex(c) end Use it like this:
local red = oklab_to_srgb(0.66, 0.08, 0.04) local bg = oklab_to_srgb(0.24, 0.001, 0.006) -- Red error text on a very subtle reddish background vim.api.nvim_set_hl(0, &#39;DiagnosticVirtualTextError&#39;, { fg = red, bg = blend(red, bg, 0.65) -- 65% background, 35% red }) The t parameter controls the mix. 0.0 = pure foreground color, 1.0 = pure background, 0.65 = mostly background with a hint of the foreground.
This is way better than manually picking a &ldquo;light red&rdquo; background that might not even match.
Putting It Together Just some quick examples of how to use this:
-- Background and foreground local bg = oklab_to_srgb(0.24, 0.001, 0.006) local fg = oklab_to_srgb(0.74, 0.0, 0.008) -- Make a few colors local orange = oklab_to_srgb(0.68, 0.055, 0.065) local blue = oklab_to_srgb(0.68, -0.02, -0.06) local green = oklab_to_srgb(0.64, -0.05, 0.06) local red = oklab_to_srgb(0.66, 0.08, 0.04) -- Use them vim.api.nvim_set_hl(0, &#39;Normal&#39;, { fg = fg, bg = bg }) vim.api.nvim_set_hl(0, &#39;Keyword&#39;, { fg = orange }) vim.api.nvim_set_hl(0, &#39;Function&#39;, { fg = blue }) vim.api.nvim_set_hl(0, &#39;String&#39;, { fg = green }) vim.api.nvim_set_hl(0, &#39;DiagnosticError&#39;, { fg = red }) -- Blend for subtle backgrounds vim.api.nvim_set_hl(0, &#39;DiagnosticVirtualTextError&#39;, { bg = blend(red, bg, 0.65) }) That&rsquo;s pretty much it. Pick some L values, tweak the a/b until it looks right, done.
Why This Actually Helps Before Oklab:
&ldquo;This orange looks too bright&hellip; let me try #c58960&hellip; no wait #b87a55&hellip; hmm maybe #ca8e62?&rdquo; One hour later, still tweaking After Oklab:
&ldquo;Too bright? Change L from 0.68 to 0.65&rdquo; Done in 30 seconds The real win is systematic adjustments:
Make everything 5% brighter? Add 0.05 to all L values Reduce saturation? Scale down all a/b values by 20% Switch from data-first to structure-first? Just swap the L values You&rsquo;re not guessing anymore. You&rsquo;re tuning a system.
Some Practical Tips Testing colors quickly:
local test = oklab_to_srgb(0.68, 0.055, 0.065) print(test) -- prints: #c5895b Adjusting systematically:
-- Make everything 5% brighter colors.orange = oklab_to_srgb(0.73, 0.055, 0.065) -- was 0.68 -- Reduce saturation by 20% colors.orange = oklab_to_srgb(0.68, 0.044, 0.052) -- was (0.055, 0.065) -- Warm up the whole palette colors.orange = oklab_to_srgb(0.68, 0.055, 0.075) -- increase b value When not to use Oklab: If you&rsquo;re trying to match an existing hex code exactly, just use the hex. Oklab is for designing colors, not copying them.
References Oklab spec: https://bottosson.github.io/posts/oklab/ (this is where all those magic numbers come from) That&rsquo;s it. No need to make this more complicated than it is. Pick some L values for brightness, tweak a/b until the hues look right, and you&rsquo;re done.
`,url:"https://www.functor.me/posts/oklab_design/"},"https://www.functor.me/tags/":{title:"Tags",tags:[],content:"",url:"https://www.functor.me/tags/"},"https://www.functor.me/categories/":{title:"Categories",tags:[],content:"",url:"https://www.functor.me/categories/"}}</script></footer></body></html>