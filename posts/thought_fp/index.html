<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png }><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content="When Loops Become Math: How Functional Thinking Changed My C++"><title>When Loops Become Math: How Functional Thinking Changed My C++ | glepnir's blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.0e9c0bb0a7de7a330263937778a4d7c0d0c6be7f327c69a0223c9f2fd31e00d5.css media=all><link rel=stylesheet href=/css/katex.min.css integrity="sha512-0u6F0kGPTUgsoq8qPa0w03CxxmEz3qYfl9eTPJL8DK4QJE9/XL1SSoiXoYhvDXCrBMBVWtaAIWsWoCg1TkJybA==" crossorigin=anonymous></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/><u>H</u>ome</a></li><li><a tabindex=-1 class=menu-link href=/tags><u>T</u>ags</a></li></ul></nav><div id=single-header><h1>When Loops Become Math: How Functional Thinking Changed My C++</h1><div id=single-meta><span class=datesub>Dec 27, 2025</span></div></div><aside class="hidden lg:block toc" id=tableOfContentContainer><nav id=TableOfContents><ul><li><a href=#seeing-with-math-eyes>Seeing with Math Eyes</a></li><li><a href=#the-real-breakthrough-seeing-deeper-patterns>The Real Breakthrough: Seeing Deeper Patterns</a></li><li><a href=#why-this-matters-you-can-actually-prove-things>Why This Matters: You Can Actually Prove Things</a></li><li><a href=#category-theory-sneaks-in>Category Theory Sneaks In</a></li><li><a href=#performance-actually-better>Performance? Actually Better</a></li><li><a href=#my-new-toolkit>My New Toolkit</a></li><li><a href=#the-mindset-shift>The Mindset Shift</a></li><li><a href=#functional-c-in-the-real-world>Functional C++ in the Real World</a></li><li><a href=#finally>Finally</a></li></ul></nav></aside><main><p>Last week, I was staring at two pieces of code a friend had sent me, asking
which one I preferred. They looked like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Version A
</span></span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>calculate_mean</span><span class=p>(</span><span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;&amp;</span> <span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>sum</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=nl>x</span> <span class=p>:</span> <span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sum</span> <span class=o>+=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sum</span> <span class=o>/</span> <span class=n>data</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Version B
</span></span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>calculate_stddev</span><span class=p>(</span><span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;&amp;</span> <span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>sum</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>mean</span> <span class=o>=</span> <span class=n>calculate_mean</span><span class=p>(</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=nl>x</span> <span class=p>:</span> <span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sum</span> <span class=o>+=</span> <span class=p>(</span><span class=n>x</span> <span class=o>-</span> <span class=n>mean</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>x</span> <span class=o>-</span> <span class=n>mean</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sqrt</span><span class=p>(</span><span class=n>sum</span> <span class=o>/</span> <span class=n>data</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>I looked at them for a solid five seconds before it hit me: these two loops were
fundamentally the same mathematical pattern! But in the code, that pattern was
buried under <code>for</code> loops and accumulation variables.</p><h2 id=seeing-with-math-eyes>Seeing with Math Eyes</h2><p>In math, we&rsquo;d write these calculations as:</p><span class=katex-display><span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>mean</mtext><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">
\text{mean} = \frac{1}{n} \sum_{i=1}^n x_i
</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.4306em></span><span class="mord text"><span class=mord>mean</span></span><span class=mspace style=margin-right:.2778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:2.9291em;vertical-align:-1.2777em></span><span class=mord><span class="mopen nulldelimiter"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.3214em><span style=top:-2.314em><span class=pstrut style=height:3em></span><span class=mord><span class="mord mathnormal">n</span></span></span><span style=top:-3.23em><span class=pstrut style=height:3em></span><span class=frac-line style=border-bottom-width:.04em></span></span><span style=top:-3.677em><span class=pstrut style=height:3em></span><span class=mord><span class=mord>1</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.686em><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mspace style=margin-right:.1667em></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.6514em><span style=top:-1.8723em;margin-left:0><span class=pstrut style=height:3.05em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style=top:-3.05em><span class=pstrut style=height:3.05em></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style=top:-4.3em;margin-left:0><span class=pstrut style=height:3.05em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.2777em><span></span></span></span></span></span><span class=mspace style=margin-right:.1667em></span><span class=mord><span class="mord mathnormal">x</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.3117em><span style=top:-2.55em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span></span><span class=katex-display><span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>stddev</mtext><mo>=</mo><msqrt><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">
\text{stddev} = \sqrt{\frac{1}{n} \sum_{i=1}^n (x_i - \mu)^2}
</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.6944em></span><span class="mord text"><span class=mord>stddev</span></span><span class=mspace style=margin-right:.2778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:3.1568em;vertical-align:-1.2777em></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.8791em><span class=svg-align style=top:-5.1168em><span class=pstrut style=height:5.1168em></span><span class=mord style=padding-left:1.056em><span class=mord><span class="mopen nulldelimiter"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.3214em><span style=top:-2.314em><span class=pstrut style=height:3em></span><span class=mord><span class="mord mathnormal">n</span></span></span><span style=top:-3.23em><span class=pstrut style=height:3em></span><span class=frac-line style=border-bottom-width:.04em></span></span><span style=top:-3.677em><span class=pstrut style=height:3em></span><span class=mord><span class=mord>1</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.686em><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mspace style=margin-right:.1667em></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.6514em><span style=top:-1.8723em;margin-left:0><span class=pstrut style=height:3.05em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style=top:-3.05em><span class=pstrut style=height:3.05em></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style=top:-4.3em;margin-left:0><span class=pstrut style=height:3.05em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.2777em><span></span></span></span></span></span><span class=mopen>(</span><span class=mord><span class="mord mathnormal">x</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.3117em><span style=top:-2.55em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mspace style=margin-right:.2222em></span><span class=mbin>−</span><span class=mspace style=margin-right:.2222em></span><span class="mord mathnormal">μ</span><span class=mclose><span class=mclose>)</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.7401em><span style=top:-2.989em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style=top:-3.8391em><span class=pstrut style=height:5.1168em></span><span class=hide-tail style=min-width:.742em;height:3.1968em><svg width="400em" height="3.1968em" viewBox="0 0 4e5 3196" preserveAspectRatio="xMinYMin slice"><path d="M702 80H40000040 742v3062l-4 4-4 4c-.667.7-2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1h-12l-28-84c-16.667-52-96.667-294.333-240-727l-212-643-85 170c-4-3.333-8.333-7.667-13-13l-13-13 77-155 77-156c66 199.333 139 419.667 219 661l218 661zm0 0H4e5v40H742z"/></svg></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.2777em><span></span></span></span></span></span></span></span></span></span><p>See that $\sum$ symbol? That&rsquo;s our abstraction point. In functional programming, this is called a <strong>fold</strong> (or reduce), defined as:</p><span class=katex-display><span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>fold</mtext><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>z</mi><mo separator="true">,</mo><mo stretchy="false">[</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>z</mi><mo separator="true">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
\text{fold}(f, z, [x_1, x_2, ..., x_n]) = f(f(f(z, x_1), x_2), ..., x_n)
</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord text"><span class=mord>fold</span></span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:.10764em>f</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal" style=margin-right:.04398em>z</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class=mopen>[</span><span class=mord><span class="mord mathnormal">x</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.3011em><span style=top:-2.55em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class=mord><span class="mord mathnormal">x</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.3011em><span style=top:-2.55em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class=mord>...</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class=mord><span class="mord mathnormal">x</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.1514em><span style=top:-2.55em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mclose>])</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathnormal" style=margin-right:.10764em>f</span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:.10764em>f</span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:.10764em>f</span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:.04398em>z</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class=mord><span class="mord mathnormal">x</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.3011em><span style=top:-2.55em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mclose>)</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class=mord><span class="mord mathnormal">x</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.3011em><span style=top:-2.55em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mclose>)</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class=mord>...</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class=mord><span class="mord mathnormal">x</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.1514em><span style=top:-2.55em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mclose>)</span></span></span></span></span><p>Looking at my code with this new perspective:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>BinaryOp</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>fold</span><span class=p>(</span><span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>vec</span><span class=p>,</span> <span class=n>T</span> <span class=n>init</span><span class=p>,</span> <span class=n>BinaryOp</span> <span class=n>op</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>result</span> <span class=o>=</span> <span class=n>init</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=nl>x</span> <span class=p>:</span> <span class=n>vec</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>op</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now both calculations become:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>double</span> <span class=n>mean</span> <span class=o>=</span> <span class=n>fold</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=n>plus</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>{})</span> <span class=o>/</span> <span class=n>data</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>variance</span> <span class=o>=</span> <span class=n>fold</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=p>[</span><span class=n>mean</span><span class=p>](</span><span class=kt>double</span> <span class=n>acc</span><span class=p>,</span> <span class=kt>double</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>acc</span> <span class=o>+</span> <span class=p>(</span><span class=n>x</span> <span class=o>-</span> <span class=n>mean</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>x</span> <span class=o>-</span> <span class=n>mean</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>})</span> <span class=o>/</span> <span class=n>data</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span></code></pre></div><h2 id=the-real-breakthrough-seeing-deeper-patterns>The Real Breakthrough: Seeing Deeper Patterns</h2><p>I started noticing this pattern everywhere. Take this convex hull algorithm I&rsquo;d
written:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>Point</span><span class=o>&gt;</span> <span class=n>find_convex_hull</span><span class=p>(</span><span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>Point</span><span class=o>&gt;&amp;</span> <span class=n>points</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>Point</span><span class=o>&gt;</span> <span class=n>hull</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>points</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>points</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=n>j</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>bool</span> <span class=n>all_on_same_side</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>points</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>k</span> <span class=o>==</span> <span class=n>i</span> <span class=o>||</span> <span class=n>k</span> <span class=o>==</span> <span class=n>j</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>is_on_same_side</span><span class=p>(</span><span class=n>points</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>points</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=n>points</span><span class=p>[</span><span class=n>k</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>all_on_same_side</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>all_on_same_side</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>hull</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>points</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>                <span class=n>hull</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>points</span><span class=p>[</span><span class=n>j</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>remove_duplicates</span><span class=p>(</span><span class=n>hull</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Three nested loops! But with functional thinking, I saw <strong>predicate logic</strong>:</p><blockquote><p>A point pair (i,j) belongs to the convex hull boundary if and only if all
other points are on the same side of the line segment (i,j).</p></blockquote><p>Mathematically:</p><span class=katex-display><span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>∈</mo><mtext>hull</mtext><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi mathvariant="normal">∀</mi><mi>k</mi><mo mathvariant="normal">≠</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>:</mo><mtext>same_side</mtext><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
(i,j) \in \text{hull} \iff \forall k \neq i,j : \text{same\_side}(i,j,k)
</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mopen>(</span><span class="mord mathnormal">i</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal" style=margin-right:.05724em>j</span><span class=mclose>)</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>∈</span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:.7184em;vertical-align:-.024em></span><span class="mord text"><span class=mord>hull</span></span><span class=mspace style=margin-right:.2778em></span><span class=mspace style=margin-right:.2778em></span><span class=mrel>⟺</span><span class=mspace style=margin-right:.2778em></span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:.8889em;vertical-align:-.1944em></span><span class=mord>∀</span><span class="mord mathnormal" style=margin-right:.03148em>k</span><span class=mspace style=margin-right:.2778em></span><span class=mrel><span class=mrel><span class="mord vbox"><span class=thinbox><span class=rlap><span class=strut style=height:.8889em;vertical-align:-.1944em></span><span class=inner><span class=mord><span class=mrel></span></span></span><span class=fix></span></span></span></span></span><span class=mrel>=</span></span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:.854em;vertical-align:-.1944em></span><span class="mord mathnormal">i</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal" style=margin-right:.05724em>j</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>:</span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:1.06em;vertical-align:-.31em></span><span class="mord text"><span class=mord>same_side</span></span><span class=mopen>(</span><span class="mord mathnormal">i</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal" style=margin-right:.05724em>j</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal" style=margin-right:.03148em>k</span><span class=mclose>)</span></span></span></span></span><p>In C++, this becomes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>Point</span><span class=o>&gt;</span> <span class=n>find_convex_hull_fp</span><span class=p>(</span><span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>Point</span><span class=o>&gt;&amp;</span> <span class=n>points</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>pairs</span> <span class=o>=</span> <span class=n>cartesian_product</span><span class=p>(</span><span class=n>points</span><span class=p>,</span> <span class=n>points</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>is_hull_edge</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>](</span><span class=k>const</span> <span class=n>pair</span><span class=o>&lt;</span><span class=n>Point</span><span class=p>,</span> <span class=n>Point</span><span class=o>&gt;&amp;</span> <span class=n>edge</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>all_of</span><span class=p>(</span><span class=n>points</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>points</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>](</span><span class=k>const</span> <span class=n>Point</span><span class=o>&amp;</span> <span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>&amp;</span><span class=n>p</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>edge</span><span class=p>.</span><span class=n>first</span> <span class=o>||</span> <span class=o>&amp;</span><span class=n>p</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>edge</span><span class=p>.</span><span class=n>second</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>                   <span class=n>is_on_same_side</span><span class=p>(</span><span class=n>edge</span><span class=p>.</span><span class=n>first</span><span class=p>,</span> <span class=n>edge</span><span class=p>.</span><span class=n>second</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>filter</span><span class=p>(</span><span class=n>pairs</span><span class=p>,</span> <span class=n>is_hull_edge</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           <span class=o>|</span> <span class=n>transform</span><span class=p>([](</span><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>p</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>vector</span><span class=p>{</span><span class=n>p</span><span class=p>.</span><span class=n>first</span><span class=p>,</span> <span class=n>p</span><span class=p>.</span><span class=n>second</span><span class=p>};</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>           <span class=o>|</span> <span class=n>flatten</span><span class=p>()</span>
</span></span><span class=line><span class=cl>           <span class=o>|</span> <span class=n>unique</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=why-this-matters-you-can-actually-prove-things>Why This Matters: You Can Actually Prove Things</h2><p>Here&rsquo;s the cool part: functional code is easier to <strong>reason about</strong>.</p><p>With the original code, proving correctness meant:</p><ol><li>Tracking three loop variables</li><li>Understanding when the <code>break</code> happens</li><li>Verifying when <code>hull</code> gets updated</li></ol><p>With the functional version:</p><ol><li><code>cartesian_product</code> generates all point pairs (obvious)</li><li><code>is_hull_edge</code> is a direct translation of the mathematical definition</li><li>The composition uses standard, well-understood operations</li></ol><p>I can even write tests that verify mathematical properties:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Convex hull property: all points should be inside the hull
</span></span></span><span class=line><span class=cl><span class=n>TEST</span><span class=p>(</span><span class=n>ConvexHull</span><span class=p>,</span> <span class=n>AllPointsInsideHull</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>points</span> <span class=o>=</span> <span class=n>generate_random_points</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>hull</span> <span class=o>=</span> <span class=n>find_convex_hull_fp</span><span class=p>(</span><span class=n>points</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=nl>p</span> <span class=p>:</span> <span class=n>points</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ASSERT_TRUE</span><span class=p>(</span><span class=n>is_point_inside_convex_polygon</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>hull</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=category-theory-sneaks-in>Category Theory Sneaks In</h2><p>Recently, I was writing a config parser with multiple operations that could fail:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>optional</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>parse_timeout</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>optional</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>parse_hostname</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>optional</span><span class=o>&lt;</span><span class=n>Config</span><span class=o>&gt;</span> <span class=n>create_config</span><span class=p>(</span><span class=kt>int</span> <span class=n>timeout</span><span class=p>,</span> <span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>host</span><span class=p>);</span>
</span></span></code></pre></div><p>The traditional way:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>optional</span><span class=o>&lt;</span><span class=n>Config</span><span class=o>&gt;</span> <span class=n>parse_config</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>timeout_str</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                              <span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>host_str</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>timeout</span> <span class=o>=</span> <span class=n>parse_timeout</span><span class=p>(</span><span class=n>timeout_str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>timeout</span><span class=p>)</span> <span class=k>return</span> <span class=n>nullopt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>host</span> <span class=o>=</span> <span class=n>parse_hostname</span><span class=p>(</span><span class=n>host_str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>host</span><span class=p>)</span> <span class=k>return</span> <span class=n>nullopt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>create_config</span><span class=p>(</span><span class=o>*</span><span class=n>timeout</span><span class=p>,</span> <span class=o>*</span><span class=n>host</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The functional way uses a pattern (some people call it a monad, but I just call
it useful):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Func</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>and_then</span><span class=p>(</span><span class=k>const</span> <span class=n>optional</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>opt</span><span class=p>,</span> <span class=n>Func</span> <span class=n>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>-&gt;</span> <span class=k>decltype</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>opt</span><span class=p>.</span><span class=n>value</span><span class=p>()))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>opt</span><span class=p>)</span> <span class=k>return</span> <span class=k>decltype</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>opt</span><span class=p>.</span><span class=n>value</span><span class=p>()))();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>f</span><span class=p>(</span><span class=o>*</span><span class=n>opt</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>optional</span><span class=o>&lt;</span><span class=n>Config</span><span class=o>&gt;</span> <span class=n>parse_config_fp</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>timeout_str</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                 <span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>host_str</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>and_then</span><span class=p>(</span><span class=n>parse_timeout</span><span class=p>(</span><span class=n>timeout_str</span><span class=p>),</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>](</span><span class=kt>int</span> <span class=n>timeout</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>and_then</span><span class=p>(</span><span class=n>parse_hostname</span><span class=p>(</span><span class=n>host_str</span><span class=p>),</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>](</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>host</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>create_config</span><span class=p>(</span><span class=n>timeout</span><span class=p>,</span> <span class=n>host</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Mathematically, this is composition in the Kleisli category:</p><span class=katex-display><span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>M</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace width="1em"/><mi>g</mi><mo>:</mo><mi>B</mi><mo>→</mo><mi>M</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mspace></mspace><mi>g</mi><msub><mo>∘</mo><mi>K</mi></msub><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>M</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
f: A \to M(B), \quad g: B \to M(C) \\
g \circ_K f: A \to M(C)
</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.8889em;vertical-align:-.1944em></span><span class="mord mathnormal" style=margin-right:.10764em>f</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>:</span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:.6833em></span><span class="mord mathnormal">A</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>→</span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathnormal" style=margin-right:.10903em>M</span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:.05017em>B</span><span class=mclose>)</span><span class=mpunct>,</span><span class=mspace style=margin-right:1em></span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal" style=margin-right:.03588em>g</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>:</span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:.6833em></span><span class="mord mathnormal" style=margin-right:.05017em>B</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>→</span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathnormal" style=margin-right:.10903em>M</span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:.07153em>C</span><span class=mclose>)</span><span class=mspace></span><span class="mord mathnormal" style=margin-right:.03588em>g</span><span class=mspace style=margin-right:.2222em></span><span class=mbin><span class=mbin>∘</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.3283em><span style=top:-2.55em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style=margin-right:.07153em>K</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mspace style=margin-right:.2222em></span></span><span class=base><span class=strut style=height:.8889em;vertical-align:-.1944em></span><span class="mord mathnormal" style=margin-right:.10764em>f</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>:</span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:.6833em></span><span class="mord mathnormal">A</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>→</span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathnormal" style=margin-right:.10903em>M</span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:.07153em>C</span><span class=mclose>)</span></span></span></span></span><h2 id=performance-actually-better>Performance? Actually Better</h2><p>People say functional code is slow. Modern C++ compilers are smart:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Hand-written &#34;optimized&#34; version
</span></span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>sum_squares</span><span class=p>(</span><span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;&amp;</span> <span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>sum</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=nl>x</span> <span class=p>:</span> <span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sum</span> <span class=o>+=</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Functional version
</span></span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>sum_squares_fp</span><span class=p>(</span><span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;&amp;</span> <span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fold</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=p>[](</span><span class=kt>double</span> <span class=n>acc</span><span class=p>,</span> <span class=kt>double</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>acc</span> <span class=o>+</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>With <code>-O3</code>, GCC generates identical assembly for both. The functional version is
actually safer—no loop variables, no bounds checking worries.</p><h2 id=my-new-toolkit>My New Toolkit</h2><p>Here&rsquo;s what functional thinking added to my C++ toolbox:</p><ol><li><strong>map/filter/reduce</strong> - The basics for working with collections</li><li><strong>Function composition</strong> - <code>compose(f, g)(x) = f(g(x))</code></li><li><strong>Currying</strong> - <code>curry(f)(a)(b) = f(a, b)</code></li><li><strong>Lazy evaluation</strong> - Using <code>generator</code> or <code>ranges::view</code></li></ol><p>Like currying for configuration:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>create_server</span> <span class=o>=</span> <span class=n>curry</span><span class=p>([](</span><span class=kt>int</span> <span class=n>port</span><span class=p>,</span> <span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>host</span><span class=p>,</span> <span class=n>Config</span> <span class=n>config</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Server</span><span class=p>{</span><span class=n>port</span><span class=p>,</span> <span class=n>host</span><span class=p>,</span> <span class=n>config</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>create_local_server</span> <span class=o>=</span> <span class=n>create_server</span><span class=p>(</span><span class=mi>8080</span><span class=p>,</span> <span class=s>&#34;localhost&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>server</span> <span class=o>=</span> <span class=n>create_local_server</span><span class=p>(</span><span class=n>config</span><span class=p>);</span>
</span></span></code></pre></div><h2 id=the-mindset-shift>The Mindset Shift</h2><p>Functional programming taught me something important: <strong>code is math, and the
compiler is my proof assistant</strong>.</p><p>Before: I wrote loops thinking &ldquo;do this repeatedly&rdquo;.
Now: I write <code>fold</code> thinking &ldquo;apply this associative operation&rdquo;.</p><p>Before: I wrote conditionals thinking &ldquo;if this, then that&rdquo;.
Now: I write <code>filter</code> thinking &ldquo;select elements satisfying this predicate&rdquo;.</p><p>This mindset lets me write code that&rsquo;s easier to prove correct. Last week I
found a bug and mentally traced it:</p><pre tabindex=0><code>Given: filter(is_even, [1,2,3,4]) = [2,4]
Given: map(square, [2,4]) = [4,16]
Given: fold(add, 0, [4,16]) = 20
Therefore: sum of squares of even numbers = 20
</code></pre><p>Writing it down like that was the proof.</p><h2 id=functional-c-in-the-real-world>Functional C++ in the Real World</h2><p>This is how I write production code now:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// HTTP request processing pipeline
</span></span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>handle_request</span> <span class=o>=</span> <span class=n>compose</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>validate_request</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>authenticate</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>parse_body</span><span class=o>&lt;</span><span class=n>Order</span><span class=o>&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>process_order</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>create_response</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Or with ranges
</span></span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>valid_orders</span> <span class=o>=</span> <span class=n>requests</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>views</span><span class=o>::</span><span class=n>filter</span><span class=p>(</span><span class=n>is_valid_order</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>views</span><span class=o>::</span><span class=n>transform</span><span class=p>(</span><span class=n>parse_order</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>views</span><span class=o>::</span><span class=n>filter</span><span class=p>([](</span><span class=k>const</span> <span class=n>Order</span><span class=o>&amp;</span> <span class=n>o</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>o</span><span class=p>.</span><span class=n>total</span> <span class=o>&gt;</span> <span class=mf>100.0</span><span class=p>;</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>views</span><span class=o>::</span><span class=n>transform</span><span class=p>(</span><span class=n>apply_discount</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>ranges</span><span class=o>::</span><span class=n>to</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&gt;</span><span class=p>();</span>
</span></span></code></pre></div><p>This isn&rsquo;t &ldquo;functional C++"—it&rsquo;s just C++. But it&rsquo;s C++ written with functional
thinking.</p><h2 id=finally>Finally</h2><p>When I started seeing loops through mathematical eyes, they stopped being loops
and became instances of algebraic structures. That perspective lets me write
code that&rsquo;s cleaner, more correct, and honestly more fun to write.</p><p>Maybe that&rsquo;s the end goal of programming: code stops being instructions and
becomes executable mathematics.</p></main><div class=sponsor><a href=https://github.com/sponsors/glepnir target=_blank rel="noopener noreferrer" class=sponsor-btn>❤️ Sponsor</a></div><section class=comments><script src=https://giscus.app/client.js data-repo=glepnir/glepnir.github.io data-repo-id data-category=General data-category-id data-mapping=pathname data-strict=0 data-reactions-enabled data-emit-metadata data-input-position data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script></section><br><footer class=site-footer><p class=footer-meta>© 2025 glepnir ·
<a href=https://github.com/glepnir>GitHub</a> ·
<a href=https://reddit.com/u/glephunter>Reddit</a> ·
<a href=https://www.functor.me/index.xml>RSS</a></p><script defer>document.addEventListener("keydown",function(e){if(document.activeElement.isContentEditable)return!1;if(document.activeElement.tagName=="INPUT")return!1;if(e.altKey||e.ctrlKey||e.shiftKey)return!1;var t=e.key;if(t==="h")e.preventDefault(),e.stopPropagation(),window.location.href="/";else if(t==="t")e.preventDefault(),e.stopPropagation(),window.location.href=`https://${location.hostname}/tags`;else if(t==="i"){e.preventDefault(),e.stopPropagation();const t=document.querySelectorAll("input");for(let e=0;e<t.length;e++)if(t[e].offsetParent!==null){t[e].selectionStart=t[e].selectionEnd=t[e].value.length,t[e].focus();break}}return!1})</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,200))}setTimeout(scrollHandler,100)</script><script defer>function getTextContentRecursively(e){let t="";if(e.nodeType===Node.TEXT_NODE)return e.textContent||"";for(const n of e.childNodes)t+=getTextContentRecursively(n);return t}function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]:not(.output):not([class*="language-console"])');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const n=getTextContentRecursively(e);navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script>window.store={"https://www.functor.me/":{title:"glepnir's blog",tags:[],content:"",url:"https://www.functor.me/"},"https://www.functor.me/posts/":{title:"Posts",tags:[],content:"",url:"https://www.functor.me/posts/"},"https://www.functor.me/posts/thought_fp/":{title:"When Loops Become Math: How Functional Thinking Changed My C++",tags:[],content:`Last week, I was staring at two pieces of code a friend had sent me, asking which one I preferred. They looked like this:
// Version A double calculate_mean(const vector&lt;double&gt;&amp; data) { double sum = 0.0; for (const auto&amp; x : data) { sum += x; } return sum / data.size(); } // Version B double calculate_stddev(const vector&lt;double&gt;&amp; data) { double sum = 0.0; double mean = calculate_mean(data); for (const auto&amp; x : data) { sum += (x - mean) * (x - mean); } return sqrt(sum / data.size()); } I looked at them for a solid five seconds before it hit me: these two loops were fundamentally the same mathematical pattern! But in the code, that pattern was buried under for loops and accumulation variables.
Seeing with Math Eyes In math, we&rsquo;d write these calculations as:
mean=1n∑i=1nxi \\text{mean} = \\frac{1}{n} \\sum_{i=1}^n x_i mean=n1​i=1∑n​xi​stddev=1n∑i=1n(xi−μ)2 \\text{stddev} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2} stddev=n1​i=1∑n​(xi​−μ)2​See that $\\sum$ symbol? That&rsquo;s our abstraction point. In functional programming, this is called a fold (or reduce), defined as:
fold(f,z,[x1,x2,...,xn])=f(f(f(z,x1),x2),...,xn) \\text{fold}(f, z, [x_1, x_2, ..., x_n]) = f(f(f(z, x_1), x_2), ..., x_n) fold(f,z,[x1​,x2​,...,xn​])=f(f(f(z,x1​),x2​),...,xn​)Looking at my code with this new perspective:
template&lt;typename T, typename BinaryOp&gt; T fold(const vector&lt;T&gt;&amp; vec, T init, BinaryOp op) { T result = init; for (const auto&amp; x : vec) { result = op(result, x); } return result; } Now both calculations become:
double mean = fold(data, 0.0, plus&lt;double&gt;{}) / data.size(); double variance = fold(data, 0.0, [mean](double acc, double x) { return acc + (x - mean) * (x - mean); }) / data.size(); The Real Breakthrough: Seeing Deeper Patterns I started noticing this pattern everywhere. Take this convex hull algorithm I&rsquo;d written:
vector&lt;Point&gt; find_convex_hull(const vector&lt;Point&gt;&amp; points) { vector&lt;Point&gt; hull; for (size_t i = 0; i &lt; points.size(); ++i) { for (size_t j = 0; j &lt; points.size(); ++j) { if (i == j) continue; bool all_on_same_side = true; for (size_t k = 0; k &lt; points.size(); ++k) { if (k == i || k == j) continue; if (!is_on_same_side(points[i], points[j], points[k])) { all_on_same_side = false; break; } } if (all_on_same_side) { hull.push_back(points[i]); hull.push_back(points[j]); } } } return remove_duplicates(hull); } Three nested loops! But with functional thinking, I saw predicate logic:
A point pair (i,j) belongs to the convex hull boundary if and only if all other points are on the same side of the line segment (i,j).
Mathematically: (i,j)∈hull ⟺ ∀k≠i,j:same_side(i,j,k) (i,j) \\in \\text{hull} \\iff \\forall k \\neq i,j : \\text{same\\_side}(i,j,k) (i,j)∈hull⟺∀k=i,j:same_side(i,j,k)In C++, this becomes:
vector&lt;Point&gt; find_convex_hull_fp(const vector&lt;Point&gt;&amp; points) { auto pairs = cartesian_product(points, points); auto is_hull_edge = [&amp;](const pair&lt;Point, Point&gt;&amp; edge) { return all_of(points.begin(), points.end(), [&amp;](const Point&amp; p) { return &amp;p == &amp;edge.first || &amp;p == &amp;edge.second || is_on_same_side(edge.first, edge.second, p); }); }; return filter(pairs, is_hull_edge) | transform([](auto&amp;&amp; p) { return vector{p.first, p.second}; }) | flatten() | unique(); } Why This Matters: You Can Actually Prove Things Here&rsquo;s the cool part: functional code is easier to reason about.
With the original code, proving correctness meant:
Tracking three loop variables Understanding when the break happens Verifying when hull gets updated With the functional version:
cartesian_product generates all point pairs (obvious) is_hull_edge is a direct translation of the mathematical definition The composition uses standard, well-understood operations I can even write tests that verify mathematical properties:
// Convex hull property: all points should be inside the hull TEST(ConvexHull, AllPointsInsideHull) { auto points = generate_random_points(100); auto hull = find_convex_hull_fp(points); for (const auto&amp; p : points) { ASSERT_TRUE(is_point_inside_convex_polygon(p, hull)); } } Category Theory Sneaks In Recently, I was writing a config parser with multiple operations that could fail:
optional&lt;int&gt; parse_timeout(const string&amp; str); optional&lt;string&gt; parse_hostname(const string&amp; str); optional&lt;Config&gt; create_config(int timeout, const string&amp; host); The traditional way:
optional&lt;Config&gt; parse_config(const string&amp; timeout_str, const string&amp; host_str) { auto timeout = parse_timeout(timeout_str); if (!timeout) return nullopt; auto host = parse_hostname(host_str); if (!host) return nullopt; return create_config(*timeout, *host); } The functional way uses a pattern (some people call it a monad, but I just call it useful):
template&lt;typename T, typename Func&gt; auto and_then(const optional&lt;T&gt;&amp; opt, Func f) -&gt; decltype(f(opt.value())) { if (!opt) return decltype(f(opt.value()))(); return f(*opt); } optional&lt;Config&gt; parse_config_fp(const string&amp; timeout_str, const string&amp; host_str) { return and_then(parse_timeout(timeout_str), [&amp;](int timeout) { return and_then(parse_hostname(host_str), [&amp;](const string&amp; host) { return create_config(timeout, host); }); }); } Mathematically, this is composition in the Kleisli category: f:A→M(B),g:B→M(C)g∘Kf:A→M(C) f: A \\to M(B), \\quad g: B \\to M(C) \\\\ g \\circ_K f: A \\to M(C) f:A→M(B),g:B→M(C)g∘K​f:A→M(C)Performance? Actually Better People say functional code is slow. Modern C++ compilers are smart:
// Hand-written &#34;optimized&#34; version double sum_squares(const vector&lt;double&gt;&amp; data) { double sum = 0.0; for (const auto&amp; x : data) { sum += x * x; } return sum; } // Functional version double sum_squares_fp(const vector&lt;double&gt;&amp; data) { return fold(data, 0.0, [](double acc, double x) { return acc + x * x; }); } With -O3, GCC generates identical assembly for both. The functional version is actually safer—no loop variables, no bounds checking worries.
My New Toolkit Here&rsquo;s what functional thinking added to my C++ toolbox:
map/filter/reduce - The basics for working with collections Function composition - compose(f, g)(x) = f(g(x)) Currying - curry(f)(a)(b) = f(a, b) Lazy evaluation - Using generator or ranges::view Like currying for configuration:
auto create_server = curry([](int port, const string&amp; host, Config config) { return Server{port, host, config}; }); auto create_local_server = create_server(8080, &#34;localhost&#34;); auto server = create_local_server(config); The Mindset Shift Functional programming taught me something important: code is math, and the compiler is my proof assistant.
Before: I wrote loops thinking &ldquo;do this repeatedly&rdquo;. Now: I write fold thinking &ldquo;apply this associative operation&rdquo;.
Before: I wrote conditionals thinking &ldquo;if this, then that&rdquo;. Now: I write filter thinking &ldquo;select elements satisfying this predicate&rdquo;.
This mindset lets me write code that&rsquo;s easier to prove correct. Last week I found a bug and mentally traced it:
Given: filter(is_even, [1,2,3,4]) = [2,4] Given: map(square, [2,4]) = [4,16] Given: fold(add, 0, [4,16]) = 20 Therefore: sum of squares of even numbers = 20 Writing it down like that was the proof.
Functional C++ in the Real World This is how I write production code now:
// HTTP request processing pipeline auto handle_request = compose( validate_request, authenticate, parse_body&lt;Order&gt;, process_order, create_response ); // Or with ranges auto valid_orders = requests | views::filter(is_valid_order) | views::transform(parse_order) | views::filter([](const Order&amp; o) { return o.total &gt; 100.0; }) | views::transform(apply_discount) | ranges::to&lt;vector&gt;(); This isn&rsquo;t &ldquo;functional C++&quot;—it&rsquo;s just C++. But it&rsquo;s C++ written with functional thinking.
Finally When I started seeing loops through mathematical eyes, they stopped being loops and became instances of algebraic structures. That perspective lets me write code that&rsquo;s cleaner, more correct, and honestly more fun to write.
Maybe that&rsquo;s the end goal of programming: code stops being instructions and becomes executable mathematics.
`,url:"https://www.functor.me/posts/thought_fp/"},"https://www.functor.me/tags/color-theory/":{title:"Color-Theory",tags:[],content:"",url:"https://www.functor.me/tags/color-theory/"},"https://www.functor.me/tags/neovim/":{title:"Neovim",tags:[],content:"",url:"https://www.functor.me/tags/neovim/"},"https://www.functor.me/tags/oklab/":{title:"Oklab",tags:[],content:"",url:"https://www.functor.me/tags/oklab/"},"https://www.functor.me/posts/oklab_design/":{title:"Stop Guessing Hex Codes: A Better Way to Pick Theme Colors",tags:["neovim","oklab","color-theory"],content:`I&rsquo;ve probably made like 20 different Neovim themes over the years. Each time I thought &ldquo;this is the one&rdquo; and each time, a month later, I&rsquo;d be tweaking colors again because something just felt&hellip; off.
The problem? I was doing what everyone does—picking colors by eye, converting between RGB and HSL, hoping the math would somehow make sense. Spoiler: it doesn&rsquo;t.
Then I found Oklab and everything got way easier.
RGB/HSL Are Kinda Broken for This Here&rsquo;s the thing: in RGB, changing red from 200 to 210 might look like a tiny shift, but changing blue from 200 to 210 could be a massive difference. HSL is better but still weird—adjusting saturation can make some colors way brighter and others barely change.
You end up with this:
-- Wait, which one is brighter? 🤷 local color1 = &#34;#c5895b&#34; local color2 = &#34;#a87d52&#34; No idea without actually looking at them. And if you want to make color1 &ldquo;just a bit dimmer&rdquo;? Good luck.
Enter Oklab: Colors That Actually Make Sense Oklab is a &ldquo;perceptually uniform&rdquo; color space. Translation: move a color 0.1 units and it looks 0.1 units different. Predictably.
It has three channels:
L (0-1): Brightness. 0 = black, 1 = white, simple. a (-0.4 to +0.4): Red ↔ Green b (-0.4 to +0.4): Yellow ↔ Blue Want an orange that&rsquo;s 68% bright? Easy:
oklab_to_srgb(0.68, 0.055, 0.065) -- L=0.68, slightly red, slightly yellow = orange Want it brighter? Change the first number:
oklab_to_srgb(0.72, 0.055, 0.065) -- Same hue, 4% brighter That&rsquo;s it. No guessing.
Implementation The conversion from Oklab to RGB goes through a few steps:
Step 1: Oklab → LMS (cone response) [lms]=[10.39630.21581−0.1056−0.06391−0.0895−1.2915][Lab] \\begin{bmatrix} l \\\\ m \\\\ s \\end{bmatrix} = \\begin{bmatrix} 1 &amp; 0.3963 &amp; 0.2158 \\\\ 1 &amp; -0.1056 &amp; -0.0639 \\\\ 1 &amp; -0.0895 &amp; -1.2915 \\end{bmatrix} \\begin{bmatrix} L \\\\ a \\\\ b \\end{bmatrix} ​lms​​=​111​0.3963−0.1056−0.0895​0.2158−0.0639−1.2915​​​Lab​​Step 2: Inverse cube root LMSlinear=[l3,m3,s3]T \\text{LMS}_{\\text{linear}} = [l^3, m^3, s^3]^T LMSlinear​=[l3,m3,s3]TStep 3: LMS → Linear RGB [RGB]=[4.0767−3.30770.2310−1.26842.6098−0.3413−0.0042−0.70341.7076][l3m3s3] \\begin{bmatrix} R \\\\ G \\\\ B \\end{bmatrix} = \\begin{bmatrix} 4.0767 &amp; -3.3077 &amp; 0.2310 \\\\ -1.2684 &amp; 2.6098 &amp; -0.3413 \\\\ -0.0042 &amp; -0.7034 &amp; 1.7076 \\end{bmatrix} \\begin{bmatrix} l^3 \\\\ m^3 \\\\ s^3 \\end{bmatrix} ​RGB​​=​4.0767−1.2684−0.0042​−3.30772.6098−0.7034​0.2310−0.34131.7076​​​l3m3s3​​Step 4: Gamma correction (sRGB) CsRGB={12.92×Clinearif Clinear≤0.00313081.055×Clinear1/2.4−0.055otherwise C_{\\text{sRGB}} = \\begin{cases} 12.92 \\times C_{\\text{linear}} &amp; \\text{if } C_{\\text{linear}} \\leq 0.0031308 \\\\ 1.055 \\times C_{\\text{linear}}^{1/2.4} - 0.055 &amp; \\text{otherwise} \\end{cases} CsRGB​={12.92×Clinear​1.055×Clinear1/2.4​−0.055​if Clinear​≤0.0031308otherwise​Here&rsquo;s the implementation:
local function oklab_to_linear_rgb(L, a, b) -- Transform Oklab to LMS (cone response) local l = L + 0.3963377774 * a + 0.2158037573 * b local m = L - 0.1055613458 * a - 0.0638541728 * b local s = L - 0.0894841775 * a - 1.2914855480 * b -- Apply inverse cube root local l3, m3, s3 = l * l * l, m * m * m, s * s * s -- LMS to linear RGB local r = 4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3 local g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3 local b_out = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3 return r, g, b_out end local function linear_to_srgb_component(c) if c &lt;= 0.0031308 then return c * 12.92 else return 1.055 * (c ^ (1 / 2.4)) - 0.055 end end local function oklab_to_srgb(L, a, b) local r, g, b_comp = oklab_to_linear_rgb(L, a, b) r = linear_to_srgb_component(r) g = linear_to_srgb_component(g) b_comp = linear_to_srgb_component(b_comp) -- Convert to 8-bit and clamp r = math.floor(math.max(0, math.min(1, r)) * 255 + 0.5) g = math.floor(math.max(0, math.min(1, g)) * 255 + 0.5) b_comp = math.floor(math.max(0, math.min(1, b_comp)) * 255 + 0.5) return string.format(&#39;#%02x%02x%02x&#39;, r, g, b_comp) end Those magic numbers come from the Oklab spec. Just copy-paste and it works.
Designing a Palette Here&rsquo;s how I actually use this. Instead of random hex codes, I think in terms of brightness and hue.
Background and foreground first:
local colors = {} -- Dark but not pure black (L=0.24, basically neutral) colors.bg = oklab_to_srgb(0.24, 0.001, 0.006) -- Bright text (L=0.74, also basically neutral) colors.fg = oklab_to_srgb(0.74, 0.0, 0.008) Then decide on a brightness hierarchy.
There are two common approaches:
Style 1: Structure-First
Brighten keywords, functions, types - emphasize code structure Dim data (strings, numbers) - they&rsquo;re secondary Example: structure at L=0.68, data at L=0.64 Style 2: Data-First (Tonsky&rsquo;s philosophy)
Dim keywords (low brightness + low saturation) - they&rsquo;re just syntactic noise Brighten function definitions, strings, numbers - that&rsquo;s your actual code Example: keywords at L=0.60, data at L=0.68-0.70 How to Pick a/b Values (Hue) Here&rsquo;s a quick reference for common colors in Oklab space:
-- Red: a &gt; 0, b near 0 or slightly positive oklab_to_srgb(L, 0.08, 0.04) -- orange-red oklab_to_srgb(L, 0.10, 0.02) -- pure red oklab_to_srgb(L, 0.10, -0.02) -- magenta-red -- Orange: a &gt; 0, b &gt; 0, roughly equal oklab_to_srgb(L, 0.055, 0.065) -- typical orange oklab_to_srgb(L, 0.05, 0.07) -- more yellow-orange -- Yellow: a ≈ 0, b &gt; 0 oklab_to_srgb(L, 0.02, 0.08) -- yellow-orange oklab_to_srgb(L, 0.0, 0.08) -- pure yellow oklab_to_srgb(L, -0.02, 0.08) -- yellow-green -- Green: a &lt; 0, b &gt; 0 oklab_to_srgb(L, -0.05, 0.06) -- typical green oklab_to_srgb(L, -0.08, 0.04) -- deeper green -- Cyan: a &lt; 0, b &lt; 0, |a| &gt; |b| oklab_to_srgb(L, -0.055, -0.01) -- cyan oklab_to_srgb(L, -0.06, -0.03) -- more blue-cyan -- Blue: a &lt; 0, b &lt; 0, |b| &gt; |a| oklab_to_srgb(L, -0.02, -0.06) -- typical blue oklab_to_srgb(L, -0.01, -0.08) -- deeper blue -- Violet/Purple: a &gt; 0, b &lt; 0 oklab_to_srgb(L, 0.05, -0.04) -- violet oklab_to_srgb(L, 0.08, -0.06) -- purple Saturation control: saturation=a2+b2\\text{saturation} = \\sqrt{a^2 + b^2}saturation=a2+b2​
s &lt; 0.05: very muted, almost gray s ≈ 0.08: moderate, comfortable for long sessions s &gt; 0.10: vivid, can be fatiguing So if you want a &ldquo;medium orange at 68% brightness with moderate saturation around 0.08&rdquo;:
-- Start with the hue ratio you want (orange ≈ equal a and b) -- Then scale to get saturation ≈ 0.08 local orange = oklab_to_srgb(0.68, 0.055, 0.065) -- sqrt(0.055² + 0.065²) ≈ 0.085 Blending Colors Sometimes you need a subtle background color—like for diagnostic messages. You want it to be related to the error color but way more subtle.
Here&rsquo;s my blend function:
local function hex_to_rgb(hex) hex = hex:gsub(&#39;#&#39;, &#39;&#39;) return { tonumber(hex:sub(1, 2), 16), tonumber(hex:sub(3, 4), 16), tonumber(hex:sub(5, 6), 16), } end local function rgb_to_hex(c) return string.format(&#39;#%02x%02x%02x&#39;, c[1], c[2], c[3]) end local function blend(fg, t) local a, b = hex_to_rgb(fg), hex_to_rgb(colors.bg) local c = { math.floor(a[1] * (1 - t) + b[1] * t + 0.5), math.floor(a[2] * (1 - t) + b[2] * t + 0.5), math.floor(a[3] * (1 - t) + b[3] * t + 0.5), } return rgb_to_hex(c) end Use it like this:
-- Red error text on a very subtle reddish background h(&#39;DiagnosticVirtualTextError&#39;, { fg = colors.red, bg = blend(colors.red, 0.65) -- 65% background, 35% red }) The t parameter controls the mix. 0.0 = pure foreground color, 1.0 = pure background, 0.65 = mostly background with a hint of the foreground.
This is way better than manually picking a &ldquo;light red&rdquo; background that might not even match.
Putting It Together Just some quick examples of how to use this:
-- Make a few colors local orange = oklab_to_srgb(0.68, 0.055, 0.065) local blue = oklab_to_srgb(0.68, -0.02, -0.06) local green = oklab_to_srgb(0.64, -0.05, 0.06) local red = oklab_to_srgb(0.66, 0.08, 0.04) vim.api.nvim_set_hl(0, &#39;Keyword&#39;, { fg = orange }) vim.api.nvim_set_hl(0, &#39;Function&#39;, { fg = blue }) vim.api.nvim_set_hl(0, &#39;String&#39;, { fg = green }) vim.api.nvim_set_hl(0, &#39;DiagnosticError&#39;, { fg = red }) vim.api.nvim_set_hl(0, &#39;DiagnosticVirtualTextError&#39;, { bg = blend(red, 0.65) }) That&rsquo;s pretty much it. Pick some L values, tweak the a/b until it looks right, done.
Why This Actually Helps Before Oklab:
&ldquo;This orange looks too bright&hellip; let me try #c58960&hellip; no wait #b87a55&hellip; hmm maybe #ca8e62?&rdquo; One hour later, still tweaking After Oklab:
&ldquo;Too bright? Change L from 0.68 to 0.65&rdquo; Done in 30 seconds The real win is systematic adjustments:
Make everything 5% brighter? Add 0.05 to all L values Reduce saturation? Scale down all a/b values by 20% Switch from data-first to structure-first? Just swap the L values You&rsquo;re not guessing anymore. You&rsquo;re tuning a system.
Some Practical Tips Testing colors quickly:
local test = oklab_to_srgb(0.68, 0.055, 0.065) print(test) -- prints: #c5895b Adjusting systematically:
-- Make everything 5% brighter colors.orange = oklab_to_srgb(0.73, 0.055, 0.065) -- was 0.68 -- Reduce saturation by 20% colors.orange = oklab_to_srgb(0.68, 0.044, 0.052) -- was (0.055, 0.065) -- Warm up the whole palette colors.orange = oklab_to_srgb(0.68, 0.055, 0.075) -- increase b value When not to use Oklab: If you&rsquo;re trying to match an existing hex code exactly, just use the hex. Oklab is for designing colors, not copying them.
References Oklab spec: https://bottosson.github.io/posts/oklab/ (this is where all those magic numbers come from) That&rsquo;s it. No need to make this more complicated than it is. Pick some L values for brightness, tweak a/b until the hues look right, and you&rsquo;re done.
`,url:"https://www.functor.me/posts/oklab_design/"},"https://www.functor.me/tags/":{title:"Tags",tags:[],content:"",url:"https://www.functor.me/tags/"},"https://www.functor.me/categories/":{title:"Categories",tags:[],content:"",url:"https://www.functor.me/categories/"}}</script></footer></body></html>