<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><title>Docker Tutorial | glepnir</title><link rel=stylesheet href=/css/reset.css><link rel=stylesheet href=/css/font.css><link rel=stylesheet href=/css/smigle.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"></head><body><header><div id=brand><a class=icon-link href=https://yupdo.org><img class=icon src=/images/avatar.svg></a><div class=text><a href=https://yupdo.org><h1>glepnir</h1></a><h3>A vimer work at neovim team and other open source project.</h3></div></div><nav><a href=/><b>Home</b></a>
|
<a href=/posts/><b>Posts</b></a>
|
<a href=/donate/><b>Donate</b></a>
|
<a href=/categories/><b>Categories</b></a>
|
<a href=/tags/><b>Tags</b></a>
|
<a href=/about/><b>About</b></a></nav><hr></header><div id=content><main><article><h1>Docker Tutorial</h1><div class=post-meta><strong><span>Posted on</span>
<time>2020-09-06</time></strong>
<span>• 1177 words</span>
<span>• 6 minute read</span><div><span>Tags:</span>
<a href=/tags/docker>docker</a></div></div><div><p>言简意赅的docker教程.可以迅速的熟悉和学会docker的各种操作.</p><p>在linux和mac上安装docker的方式如下:</p><ul><li>CentOS</li></ul><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>yum -y install yum-utils device-mapper-persistent-data lvm2
</span></span><span style=display:flex><span>yum makecache fast
</span></span><span style=display:flex><span>yum -y install docker-ce
</span></span></code></pre></div><ul><li>Mac 安装 <code>Docker for Mac</code> 即可</li></ul><h3 id=镜像加速>镜像加速</h3><ul><li>CentOS</li></ul><p>默认下载Docker会去国外服务器下载，速度较慢，可以设置为阿里云镜像源，速度更快</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>yum-config-manager --add-repo http:<span style=color:#0ff;font-weight:700>//mi</span>rrors.aliyun.com<span style=color:#0ff;font-weight:700>/docker-ce/</span>linux<span style=color:#0ff;font-weight:700>/centos/</span>docker-ce.repo
</span></span></code></pre></div><ul><li>Mac</li></ul><p>登陆到阿里云找到镜像中心/镜像加速器会看到属于你自己的镜像加速器地址</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>https:<span style=color:#0ff;font-weight:700>//c</span>r.console.aliyun.com<span style=color:#0ff;font-weight:700>/cn-hangzhou/i</span>nstances/mirrors
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f># 一般长这个样子</span>
</span></span><span style=display:flex><span>https:<span style=color:#0ff;font-weight:700>//xxxxx</span>.mirror.aliyuncs.com
</span></span></code></pre></div><p>将这个地址填写到docker的Preference的Docker Engine里 json的文件格式</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=font-weight:700>&#34;debug&#34;</span>: <span style=color:#fff;font-weight:700>true</span>,
</span></span><span style=display:flex><span>  <span style=font-weight:700>&#34;experimental&#34;</span>: <span style=color:#fff;font-weight:700>false</span>,
</span></span><span style=display:flex><span>  <span style=font-weight:700>&#34;registry-mirrors&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#0ff;font-weight:700>&#34;https://xxxx.mirror.aliyuncs.com&#34;</span>
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后重启Docker</p><ul><li>Proxy</li></ul><p>如果你使用一些proxy 软件例如ssr v2ray等,如果速度还可以的情况可以在终端使用代理的形式.</p><h3 id=启动docker>启动docker</h3><p>完成上面的操作已经简单的配置好了docker.启动docker.</p><p>安装成功后，需要手动启动，设置为开机启动，并测试一下 Docker</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#007f7f>#启动docker服务</span>
</span></span><span style=display:flex><span>systemctl start docker
</span></span><span style=display:flex><span><span style=color:#007f7f>#设置开机自动启动</span>
</span></span><span style=display:flex><span>systemctl enable docker
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#Mac 直接省略上面打开docker客户端设置开机启动，当然你可以使用brew services的方式如果你使用brew cask安装的docker</span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#测试</span>
</span></span><span style=display:flex><span>docker run hello-world
</span></span></code></pre></div><h3 id=docker的仓库>Docker的仓库</h3><ol><li>Docker官方的中央仓库设置镜像加速后速度就不会很慢推荐使用</li></ol><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>https:<span style=color:#0ff;font-weight:700>//</span>hub.docker.com/
</span></span></code></pre></div><ol start=2><li>在公司内部会采用私服的方式拉取镜像（添加配置）一般都是用linux做服务器</li></ol><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#007f7f>//需要创建 /etc/docker/daemon.json，并添加如下内容
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>{
</span></span><span style=display:flex><span>    <span style=font-weight:700>&#34;registry-mirrors&#34;</span>:[<span style=color:#0ff;font-weight:700>&#34;https://registry.docker-cn.com&#34;</span>],
</span></span><span style=display:flex><span>    <span style=font-weight:700>&#34;insecure-registries&#34;</span>:[<span style=color:#0ff;font-weight:700>&#34;ip:port&#34;</span>]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>添加后需要重启docker</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#007f7f>#重启两个服务</span>
</span></span><span style=display:flex><span>systemctl daemon-reload
</span></span><span style=display:flex><span>systemctl restart docker
</span></span></code></pre></div><h3 id=镜像的操作>镜像的操作</h3><p>docke search 查找镜像
当安装和配置好docker
后在本地上是不存在任何镜像的,这时候就需要去镜像仓库拉取需要的镜像,在拉取之前可以通过查找的操作,来查看所需要的镜像是否在仓库之中.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker search redis
</span></span></code></pre></div><p>如果查找到了redis镜像的信息,它会输出一些关于该镜像的信息例如名称,描述,star,是否官方等等,如果没有那么仓库就不存在该镜像需要换一个仓库.</p><p><code>--limit</code> 参数可以进行输出镜像的结果数量限制.一般都是使用官方镜像.</p><p>docke pull 拉取镜像</p><p>从中央仓库拉取镜像到本地 一般不填 tag 会拉去最新的也就是 latest
docker pull 镜像名称[:tag]</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#007f7f>#例如</span>
</span></span><span style=display:flex><span>docker pull mongo
</span></span></code></pre></div><p>查看本地镜像 docker images 还可以再后面加入一些参数 -q 只显示镜像id 默认是-a
列出所有镜像</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#007f7f>#输出的格式如下</span>
</span></span><span style=display:flex><span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span style=display:flex><span>mongo               latest              <span style=color:#ff0;font-weight:700>409</span>c3f937574        <span style=color:#ff0;font-weight:700>5</span> days ago          <span style=color:#ff0;font-weight:700>493</span>MB
</span></span><span style=display:flex><span>hello-world         latest              bf756fb1ae65        <span style=color:#ff0;font-weight:700>7</span> months ago        <span style=color:#ff0;font-weight:700>13.3</span>kB
</span></span></code></pre></div><p>镜像ID就是sha256 的字符串. 下载带有tag的镜像例如redis 6系列版本的镜像</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker pull redis:6<span style=color:#ff0;font-weight:700>.0.8</span>
</span></span></code></pre></div><p>删除镜像 docker rmi (-f) 镜像ID rm 一般*nix的删除前缀 i就是image的i -f
就是强制删除.当镜像在容器中时则需要-f 强制删除</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#007f7f>#例如删除mongo</span>
</span></span><span style=display:flex><span>docker rmi <span style=color:#ff0;font-weight:700>409</span>c3f937574
</span></span><span style=display:flex><span><span style=color:#007f7f>#如果要删除多个镜像</span>
</span></span><span style=display:flex><span>docker rmi id1 id2
</span></span><span style=display:flex><span><span style=color:#007f7f>#删除全部的容器</span>
</span></span><span style=display:flex><span>docker rmi -f $<span style=color:red>(</span>docker images -qa)
</span></span></code></pre></div><p>查看docker 镜像容器数据卷的占用信息</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker <span style=color:#fff;font-weight:700>system</span> df
</span></span></code></pre></div><p>镜像的导入导出</p><p>如果因为网络原因可以通过硬盘的方式传输镜像，虽然不规范，但是有效，但是这种方式导出的镜像名称和版本都是null，需要手动修改</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#007f7f>#将本地的镜像导出</span>
</span></span><span style=display:flex><span>docker save -o 导出的文件路径 镜像id
</span></span><span style=display:flex><span><span style=color:#007f7f>#加载本地的镜像文件</span>
</span></span><span style=display:flex><span>docker load -i 镜像文件
</span></span><span style=display:flex><span><span style=color:#007f7f>#修改镜像文件</span>
</span></span><span style=display:flex><span>docker tag 镜像id 新镜像名称:版本
</span></span></code></pre></div><p>例如打包mongo镜像(确保先创建你要导出的文件夹)</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker save -o ~<span style=color:#0ff;font-weight:700>/dockerimage/mo</span>ngo <span style=color:#ff0;font-weight:700>409</span>c3f937574
</span></span><span style=display:flex><span><span style=color:#007f7f>#加载本地镜像</span>
</span></span><span style=display:flex><span>docker load -i ~<span style=color:#0ff;font-weight:700>/dockerimage/mo</span>ngo
</span></span><span style=display:flex><span><span style=color:#007f7f>#output 加载镜像的layer</span>
</span></span><span style=display:flex><span>c5ff2d88f679: Loading layer  <span style=color:#ff0;font-weight:700>80.33</span>MB/<span style=color:#ff0;font-weight:700>80.33</span>MB
</span></span><span style=display:flex><span><span style=color:#ff0;font-weight:700>8</span>a9da272b7d2: Loading layer  <span style=color:#ff0;font-weight:700>340.5</span>kB/<span style=color:#ff0;font-weight:700>340.5</span>kB
</span></span><span style=display:flex><span><span style=color:#ff0;font-weight:700>1380</span>b7095b41: Loading layer  <span style=color:#ff0;font-weight:700>12.19</span>MB/<span style=color:#ff0;font-weight:700>12.19</span>MB
</span></span><span style=display:flex><span>d1e9c181d71c: Loading layer  <span style=color:#ff0;font-weight:700>3.515</span>MB/<span style=color:#ff0;font-weight:700>3.515</span>MB
</span></span><span style=display:flex><span><span style=color:#ff0;font-weight:700>4</span>dcad5cb53c6: Loading layer  <span style=color:#ff0;font-weight:700>2.048</span>kB/<span style=color:#ff0;font-weight:700>2.048</span>kB
</span></span><span style=display:flex><span><span style=color:#ff0;font-weight:700>7e48</span>cf4fe2cc: Loading layer   <span style=color:#ff0;font-weight:700>5.12</span>kB/<span style=color:#ff0;font-weight:700>5.12</span>kB
</span></span><span style=display:flex><span><span style=color:#ff0;font-weight:700>0e190450333</span>c: Loading layer  <span style=color:#ff0;font-weight:700>3.584</span>kB/<span style=color:#ff0;font-weight:700>3.584</span>kB
</span></span><span style=display:flex><span>b7e89712287a: Loading layer  <span style=color:#ff0;font-weight:700>547.4</span>MB/<span style=color:#ff0;font-weight:700>547.4</span>MB
</span></span><span style=display:flex><span><span style=color:#ff0;font-weight:700>2</span>d3d91132f03: Loading layer  <span style=color:#ff0;font-weight:700>17.41</span>kB/<span style=color:#ff0;font-weight:700>17.41</span>kB
</span></span><span style=display:flex><span>Loaded image ID: sha256:a440572ac3c10fdc02c51d46a2dcbf3760d10faf3f6a2784054e6e1057f0d92a
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#然后docker images 查看一下</span>
</span></span><span style=display:flex><span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span style=display:flex><span><span style=color:#0ff;font-weight:700>&lt;none&gt;</span>              <span style=color:#0ff;font-weight:700>&lt;none&gt;</span>              <span style=color:#ff0;font-weight:700>409</span>c3f937574        <span style=color:#ff0;font-weight:700>5</span> days ago          <span style=color:#ff0;font-weight:700>493</span>MB
</span></span><span style=display:flex><span>hello-world         latest              bf756fb1ae65        <span style=color:#ff0;font-weight:700>7</span> months ago        <span style=color:#ff0;font-weight:700>13.3</span>kB
</span></span></code></pre></div><p>这个 <code>none</code> 就是加载的已经打包到本地的mongo ID大小都是一样的. none 这个镜像叫做虚悬镜像(dangling
iamge)</p><p>修改这个虚悬镜像的name 和tag</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker tag ImageID mongo:latest
</span></span><span style=display:flex><span><span style=color:#007f7f>#再用docker images查看一下 这样就顺眼了</span>
</span></span><span style=display:flex><span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span style=display:flex><span>mongo               latest              <span style=color:#ff0;font-weight:700>409</span>c3f937574        <span style=color:#ff0;font-weight:700>5</span> days ago          <span style=color:#ff0;font-weight:700>493</span>MB
</span></span><span style=display:flex><span>hello-world         latest              bf756fb1ae65        <span style=color:#ff0;font-weight:700>7</span> months ago        <span style=color:#ff0;font-weight:700>13.3</span>kB
</span></span></code></pre></div><h3 id=容器操作>容器操作</h3><p>运行容器需要定制具体镜像，如果镜像不存在，会直接下载</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker run 镜像的ID|镜像的名称[:tag]
</span></span></code></pre></div><p>常用的参数</p><ul><li><code>-d</code>(daemon):代表后台运行容器</li><li><code>-p</code>(port):宿主机端口:容器端口：为了映射当前Linux的端口和容器的端口</li><li><code>-P</code>随机端口</li><li><code>-i</code>(interactive): 交互启动</li><li><code>-t</code>(tty): 分配一个伪终端一般与 -i一起使用</li><li><code>--name</code>:容器名称:指定容器的名称</li></ul><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker run -d -p 宿主机端口:容器端口 --name 容器名称 镜像ID 或者 镜像名称[:tag]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#例如启动mysql 之后会看到容器id的输出即为启动容器成功</span>
</span></span><span style=display:flex><span>docker run -d -p <span style=color:#ff0;font-weight:700>3309</span>:<span style=color:#ff0;font-weight:700>3306</span> --name mysql <span style=color:#ff0;font-weight:700>0</span>d
</span></span></code></pre></div><p>查看全部正在运行的容器信息</p><ul><li>-a 查看全部的容器，包括没有运行</li><li>-q 只查看容器的标识</li><li>-l 显示最近创建的容器</li><li>-n 显示最近n个创建的容器</li></ul><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker ps [-qa]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#会有这样的输出 当前容器的id</span>
</span></span><span style=display:flex><span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
</span></span><span style=display:flex><span>d00f6136b0d7        bf                  <span style=color:#0ff;font-weight:700>&#34;/hello&#34;</span>            <span style=color:#ff0;font-weight:700>5</span> seconds ago       Exited (<span style=color:#ff0;font-weight:700>0</span>) <span style=color:#ff0;font-weight:700>4</span> seconds ago                       hopeful_poitras
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#只显示最近创建的容器</span>
</span></span><span style=display:flex><span>docke ps -l
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#只显示1个创建的容器</span>
</span></span><span style=display:flex><span>docker ps -n <span style=color:#ff0;font-weight:700>1</span>
</span></span></code></pre></div><p>退出容器</p><p>当以交互式的形式启动容器后 dock run -it ubuntu bash.
会进入到容器的bash中.那么如何退出当前的容器两种办法:</p><ul><li>输入exit 会停掉正在运行的容器</li><li>快捷键ctrl+p+q 退出.不会停掉容器</li></ul><p>查看容器日志，以查看容器运行的信息</p><ul><li>-f：可以滚动查看日志的最后几行</li></ul><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker logs -f 容器id
</span></span></code></pre></div><p>进入容器的内部进行操作，例如进入容器内部的shell(默认是bash)
exec是execute的简写执行的意思。记住单词也就记住了。</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker <span style=color:#fff;font-weight:700>exec</span> -it 容器id bash
</span></span></code></pre></div><p>进入后可通过输入exit 退出回到当前的环境,并且不会停掉容器</p><p>重新连接容器 docker attach</p><p>当通过使用交互式启动容器时例如 docker run -it -d ubuntu bash
时,如上所述我们可以使用exit和快捷键退出容器.那么当我们是用快捷键退出容器后如何在进去呢.
可以使用</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker attach 容器id
</span></span><span style=display:flex><span><span style=color:#007f7f>#注意这里如果继续使用exit 退出容器仍然会停掉容器</span>
</span></span></code></pre></div><p>查看容器内部运行的进程</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker top 容器id
</span></span></code></pre></div><p>打印容器信息</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker inspect 容器id
</span></span></code></pre></div><p>容器的启动，暂停，停止，删除等操作，后续会经常使用到</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#007f7f>#暂停容器</span>
</span></span><span style=display:flex><span>docker pause 容器id
</span></span><span style=display:flex><span><span style=color:#007f7f>#恢复容器</span>
</span></span><span style=display:flex><span>docker unpause 容器id
</span></span><span style=display:flex><span><span style=color:#007f7f>#重新启动容器</span>
</span></span><span style=display:flex><span>docker restart 容器id
</span></span><span style=display:flex><span><span style=color:#007f7f>#启动运行的容器</span>
</span></span><span style=display:flex><span>docker start 容器id
</span></span><span style=display:flex><span><span style=color:#007f7f>#停止指定的容器</span>
</span></span><span style=display:flex><span>docker stop 容器id
</span></span><span style=display:flex><span><span style=color:#007f7f>#停止全部容器</span>
</span></span><span style=display:flex><span>docker stop $<span style=color:red>(</span>docker ps -qa)
</span></span><span style=display:flex><span><span style=color:#007f7f>#删除指定容器</span>
</span></span><span style=display:flex><span>docker rm 容器id
</span></span><span style=display:flex><span><span style=color:#007f7f>#删除全部容器 -f 就是force 强制删除可以删除正在运行的容器</span>
</span></span><span style=display:flex><span>docker rm (-f) $<span style=color:red>(</span>docker ps -qa)
</span></span><span style=display:flex><span><span style=color:#007f7f>#另一种方式使用管道的形式</span>
</span></span><span style=display:flex><span>docker ps -a -<span style=color:#0ff;font-weight:700>q | </span>xargs docker rm
</span></span><span style=display:flex><span><span style=color:#007f7f>#强制停止容器</span>
</span></span><span style=display:flex><span>docker <span style=color:#fff;font-weight:700>kill</span> 容器id
</span></span></code></pre></div><p>例如删除hello-world容器</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#007f7f>#查看到ID</span>
</span></span><span style=display:flex><span>docker ps -a 
</span></span><span style=display:flex><span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
</span></span><span style=display:flex><span>d00f6136b0d7        bf                  <span style=color:#0ff;font-weight:700>&#34;/hello&#34;</span>            <span style=color:#ff0;font-weight:700>5</span> seconds ago       Exited (<span style=color:#ff0;font-weight:700>0</span>) <span style=color:#ff0;font-weight:700>4</span> seconds ago                       hopeful_poitras
</span></span><span style=display:flex><span><span style=color:#007f7f>#停止容器</span>
</span></span><span style=display:flex><span>docker stop d00
</span></span><span style=display:flex><span><span style=color:#007f7f>#删除容器</span>
</span></span><span style=display:flex><span>docker rm d00
</span></span><span style=display:flex><span><span style=color:#007f7f>#查看一下</span>
</span></span><span style=display:flex><span>docker ps -a
</span></span><span style=display:flex><span><span style=color:#007f7f>#hello-world 容器已经不存在了</span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#然后就可以删除掉hello-world镜像</span>
</span></span><span style=display:flex><span>docker rmi hello-wolrd的id即可
</span></span><span style=display:flex><span><span style=color:#007f7f>#再用docker images查看一下</span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#没有了hello-world的镜像</span>
</span></span></code></pre></div><p>当然可以通过使用docker rm -f hello-world 强制删除不过在开发时候为了确保不出意外一般都是先停止在删除.</p><p>实例启动mysql容器</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#007f7f>#例如docker运行mysql</span>
</span></span><span style=display:flex><span><span style=color:red>➜</span> docker pull mysql
</span></span><span style=display:flex><span><span style=color:#007f7f>#查看镜像</span>
</span></span><span style=display:flex><span><span style=color:red>➜</span> docker images
</span></span><span style=display:flex><span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span style=display:flex><span>mysql               latest              <span style=color:#ff0;font-weight:700>0</span>d64f46acfd1        <span style=color:#ff0;font-weight:700>3</span> weeks ago         <span style=color:#ff0;font-weight:700>544</span>MB
</span></span><span style=display:flex><span><span style=color:#007f7f>#后台运行容器 -e 加上初始化的root密码 否则mysql 会启动失败(可通过logs -f查看到日志)</span>
</span></span><span style=display:flex><span><span style=color:red>➜</span> docker run -d -p <span style=color:#ff0;font-weight:700>3309</span>:<span style=color:#ff0;font-weight:700>3306</span> -e MYSQL_ROOT_PASSWORD=<span style=color:#ff0;font-weight:700>123456</span>   --name mysql <span style=color:#ff0;font-weight:700>0</span>d
</span></span><span style=display:flex><span><span style=color:#007f7f>#输出容器id 即为启动成功</span>
</span></span><span style=display:flex><span>d20bfc8e2eaf35773a911a8e5e3af8b1bce024a16e7687000d9ef476c4fc3f0e
</span></span><span style=display:flex><span><span style=color:#007f7f># 查看当前的容器</span>
</span></span><span style=display:flex><span><span style=color:red>➜</span> docker ps -a
</span></span><span style=display:flex><span>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES
</span></span><span style=display:flex><span>d20bfc8e2eaf        <span style=color:#ff0;font-weight:700>0</span>d                  <span style=color:#0ff;font-weight:700>&#34;docker-entrypoint.s…&#34;</span>   <span style=color:#ff0;font-weight:700>3</span> seconds ago       Up <span style=color:#ff0;font-weight:700>3</span> seconds        <span style=color:#ff0;font-weight:700>33060</span><span style=color:#0ff;font-weight:700>/tcp, 0.0.0.0:3309-&gt;3306/</span>tcp   mysql
</span></span><span style=display:flex><span><span style=color:#007f7f># 进入容器的内部shell环境连接mysqlclient</span>
</span></span><span style=display:flex><span>root@d20bfc8e2eaf:/<span style=color:#007f7f># mysql -u root -p</span>
</span></span><span style=display:flex><span>Enter password:
</span></span><span style=display:flex><span>Welcome to the MySQL monitor.  Commands end with ; or \g.
</span></span><span style=display:flex><span>Your MySQL connection id is <span style=color:#ff0;font-weight:700>10</span>
</span></span><span style=display:flex><span>Server version: <span style=color:#ff0;font-weight:700>8.0.21</span> MySQL Community Server - GPL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Copyright (c) <span style=color:#ff0;font-weight:700>2000</span>, <span style=color:#ff0;font-weight:700>2020</span>, Oracle and/or its affiliates. All rights reserved.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Oracle is a registered trademark of Oracle Corporation and/or its
</span></span><span style=display:flex><span>affiliates. Other names may be trademarks of their respective
</span></span><span style=display:flex><span>owners.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Type <span style=color:#0ff;font-weight:700>&#39;help;&#39;</span> or <span style=color:#0ff;font-weight:700>&#39;\h&#39;</span> <span style=color:#fff;font-weight:700>for</span> help. Type <span style=color:#0ff;font-weight:700>&#39;\c&#39;</span> to clear the current input statement.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mysql&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#成功运行了mysql</span>
</span></span><span style=display:flex><span><span style=color:#007f7f># 退出mysql</span>
</span></span><span style=display:flex><span>mysql&gt; \<span style=color:#0ff;font-weight:700>q
</span></span></span><span style=display:flex><span><span style=color:#0ff;font-weight:700># 退出容器
</span></span></span><span style=display:flex><span><span style=color:#0ff;font-weight:700></span>root@d20bfc8e2eaf:/<span style=color:#007f7f># exit</span>
</span></span></code></pre></div><p>可以通过各种数据库的gui客户端进行连接当前的mysql容器,需要注意的是这个例子中使用主机的3309做为映射端口那么在使用客户端连接的时候切记修改默认的3306端口为3309
端口。当然你也可以使用主机的3306端口映射容器的3306端口在启动容器的时候.</p><p>在编程的时候连接数据库 例如go中使用docker的mysql</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#fff;font-weight:700>func</span> main() {
</span></span><span style=display:flex><span>	ConnectSQL(<span style=color:#0ff;font-weight:700>&#34;localhost&#34;</span>, <span style=color:#0ff;font-weight:700>&#34;3309&#34;</span>, <span style=color:#0ff;font-weight:700>&#34;root&#34;</span>, <span style=color:#0ff;font-weight:700>&#34;123456&#34;</span>, <span style=color:#0ff;font-weight:700>&#34;mysql&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// ConnectSQL ...
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>func</span> ConnectSQL(host, port, uname, pass, dbname <span style=color:#fff;font-weight:700>string</span>) {
</span></span><span style=display:flex><span>	dbSource := fmt.Sprintf(
</span></span><span style=display:flex><span>		<span style=color:#0ff;font-weight:700>&#34;root:%s@tcp(%s:%s)/%s?charset=utf8&#34;</span>,
</span></span><span style=display:flex><span>		pass,
</span></span><span style=display:flex><span>		host,
</span></span><span style=display:flex><span>		port,
</span></span><span style=display:flex><span>		dbname,
</span></span><span style=display:flex><span>	)
</span></span><span style=display:flex><span>	d, err := sql.Open(<span style=color:#0ff;font-weight:700>&#34;mysql&#34;</span>, dbSource)
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>if</span> err != <span style=color:#fff;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#fff;font-weight:700>panic</span>(err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	err = d.Ping()
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>if</span> err != <span style=color:#fff;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#fff;font-weight:700>panic</span>(err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	fmt.Println(<span style=color:#0ff;font-weight:700>&#34;Connection success&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>极大的改善了开发体验，你可以简单有快速的安装不同版本和不同类型的数据库。</p><p>容器拷贝文件到主机 docker cp 容器id:容器内路径 目标主机路径</p><p>首先启动一个Ubuntu容器,然后进入到这个ubuntu容器中</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#007f7f>#启动ubuntu容器</span>
</span></span><span style=display:flex><span>docker run -it ubuntu bash
</span></span><span style=display:flex><span><span style=color:#007f7f>#目前已经在ubuntu容器内了在任何目录创建一个文件</span>
</span></span><span style=display:flex><span>touch a.txt
</span></span><span style=display:flex><span><span style=color:#007f7f>#使用重定向的方式写入一些字符串</span>
</span></span><span style=display:flex><span>echo <span style=color:#0ff;font-weight:700>&#39;from ubuntu&#39;</span> &gt; a.txt
</span></span><span style=display:flex><span><span style=color:#007f7f>#使用cat命令查看是否写入成功</span>
</span></span><span style=display:flex><span>cat a.txt
</span></span><span style=display:flex><span><span style=color:#007f7f>#正常情况会输出刚写入的字符串 from ubuntu</span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#使用ctrl+p+q退出这个容器 前面讲过快捷键不会停掉容器</span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#使用cp命令把刚才创建的a.txt文件拷贝到当前目录下</span>
</span></span><span style=display:flex><span>docker cp 容器id:<span style=color:#0ff;font-weight:700>/a.txt ./</span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#通过ls 命令查看存在a.txt文件已经拷贝成功了</span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#cat a.txt 会输出from ubuntu</span>
</span></span></code></pre></div><p>导出容器 docker export 容器id > 文件名.tar</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#007f7f>#注意导出是不会停掉正在运行的容器的</span>
</span></span><span style=display:flex><span>docker export ubuntu容器id &gt; ubuntu.tar
</span></span><span style=display:flex><span><span style=color:#007f7f>#ubuntu容器仍然在运行</span>
</span></span><span style=display:flex><span>docker  ps -a
</span></span></code></pre></div><p>导入容器镜像 cat 镜像.tar | docker import - 镜像用户/镜像名:镜像版本号</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#007f7f>#首先强制删除刚才的ubuntu镜像</span>
</span></span><span style=display:flex><span>docker rm -f ubuntu容器id
</span></span><span style=display:flex><span><span style=color:#007f7f>#查看确认已经没有了ubuntu容器</span>
</span></span><span style=display:flex><span>docker ps -a
</span></span><span style=display:flex><span><span style=color:#007f7f>#导入刚才导出的ubuntu容器镜像 这里就可以随便写一些信息</span>
</span></span><span style=display:flex><span>cat ubuntu.tar | docker <span style=color:#fff;font-weight:700>import</span> -test/test:0<span style=color:#ff0;font-weight:700>.1.0</span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#导入完成后会看到sha256的id输出 使用</span>
</span></span><span style=display:flex><span>docker images
</span></span><span style=display:flex><span><span style=color:#007f7f>#查看全部的镜像会看到刚导入的镜像</span>
</span></span></code></pre></div><h3 id=镜像>镜像</h3><p>是一种轻量级，可独立的独立软件包，它包含运行某个应用程序所需的所有内容，把应用程序和配置依赖打包成一个可交付的运行环境，这个打包好的运行环境就简称为镜像</p><p>分层镜像</p><p>当使用pull命令拉取一个新的镜像时经常看到是这样的输出</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker pull mongo
</span></span><span style=display:flex><span><span style=color:#007f7f># output</span>
</span></span><span style=display:flex><span>latest: Pulling from library/mongo
</span></span><span style=display:flex><span>b65bcf19d144: Pulling fs layer
</span></span><span style=display:flex><span><span style=color:#ff0;font-weight:700>83449</span>d568304: Pulling fs layer
</span></span><span style=display:flex><span><span style=color:#ff0;font-weight:700>20</span>d982b8a1de: Waiting
</span></span><span style=display:flex><span><span style=color:#ff0;font-weight:700>40</span>b500d3ec7f: Waiting
</span></span></code></pre></div><p>在上面的输出中会看到许多的fs layer 文件层,一个镜像是由许多个文件构成的.底层的原理就是
Union fs(联合文件系统).</p><p>Union Fs (联合文件系统)
是一种分层,轻量级的高性能文件系统,它支持对文件系统的修改作为一次提交来一层层的叠加.同时可以将不同的目录挂载到通一个虚拟文件系统下.
Union文件系统是docker镜像的基础.镜像可以通过分层来继承.基于基础的镜像可以制作各种不同应用的镜像.</p><p>特性:
一次同时加载多个文件系统,但从外面看起来,只能看到一个文件系统,联合加载会把各层文件叠加起来,这样最终的文件系统会包含所有底层的文件和目录.</p><h4 id=docker镜像加载原理>Docker镜像加载原理</h4><p>docker的镜像实际上由一层一层的文件系统组成,这种层级的文件系统叫做UnionFs.</p><p>bootfs(boot file system)主要包含bootloader和kernel,
bootloader主要是加载kernel,linux刚启动的时候会加载bootfs文件系统,在docker镜像的最底层就是引导文件系统bootfs.这一层与典型的linux或者unix系统是一样的.
当boot加载完成之后整个内核就在内存中了,此时的内存使用权就由boot转交给了kernel,此时系统也会卸载bootfs</p><p>rootfs(root file system)在bootfs之上,包含的就是典型的linux或者unix系统中的/dev /proc /bin
/etc等标准目录和文件, rootfs就是各种不同操作系统的发行版例如ubuntu centos 等等.</p><h3 id=镜像提交commit>镜像提交commit</h3><p>docker commit -m=&ldquo;提交的信息&rdquo; -a=&ldquo;作者&rdquo; 容器id 要创建的镜像名:tag</p><p>之前创建的ubuntu容器使用的官方镜像.这种镜像一般只包含一个linux
kernel没有其他任何常用的一些外部程序例如vim等.
尝试安装一个vim然后提交打包这个ubuntu容器成为一个新的带有vim的ubuntu镜像.</p><p>ubuntu的包管理器使用的是apt-get。所以先尝试更新下包管理器</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#007f7f>#更新</span>
</span></span><span style=display:flex><span>docker run -it ubuntu bash
</span></span><span style=display:flex><span>apt-get update
</span></span><span style=display:flex><span><span style=color:#007f7f>#安装vim</span>
</span></span><span style=display:flex><span>apt-get -y install vim
</span></span><span style=display:flex><span><span style=color:#007f7f>#安装完成后打开vim测试一下都正常的.提交这个镜像 用户名要与hub.docker上面一致</span>
</span></span><span style=display:flex><span>docker commit -m=<span style=color:#0ff;font-weight:700>&#34;ubuntu with vim&#34;</span> -a=<span style=color:#0ff;font-weight:700>&#34;glepnir&#34;</span> <span style=color:#ff0;font-weight:700>3730</span> glephunter/myubuntu:0<span style=color:#ff0;font-weight:700>.1.0</span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#提交镜像到hub.docker去</span>
</span></span><span style=display:flex><span>docker <span style=color:#fff;font-weight:700>push</span> glephunter/myubuntu:0<span style=color:#ff0;font-weight:700>.1.0</span>
</span></span></code></pre></div><h3 id=数据卷>数据卷</h3><p>为什么要用数据卷因为镜像往往都是很纯净的甚至都没有vi，还需要去下载一个vi才能使用。如果使用docker部署不推荐在容器内部维护项目。</p><p>数据卷：将宿主机的一个目录映射到容器的一个目录中。可以在宿主机中操作目录中的内容，那么容器内部映射的文件，也会跟着一起改变。</p><p>创建数据卷后，默认会存放在一个目录下/var/lib/docker/volumes/数据卷名称/_data</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker volume create 数据卷名称
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#创建一个go微服务数据卷</span>
</span></span><span style=display:flex><span><span style=color:red>➜</span> docker volume create go-microservices
</span></span><span style=display:flex><span>go-microservices
</span></span><span style=display:flex><span><span style=color:#007f7f># 查看数据卷</span>
</span></span><span style=display:flex><span><span style=color:red>➜</span> docker volume ls
</span></span><span style=display:flex><span>DRIVER              VOLUME NAME
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>local</span>               <span style=color:#ff0;font-weight:700>3e1</span>a82bbf69dc086edf161d5f5737c108d82f04a1c07fa24be77a48d6f7bd0de
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>local</span>               <span style=color:#ff0;font-weight:700>55</span>f0f0294ae7096d461ffc0319c8e52064856d18ce9ceb194794d39420b2c76a
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>local</span>               <span style=color:#ff0;font-weight:700>460487207e610918020</span>e8435d071e6127c98f33eb0292433a38a8c8bedaf4f38
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>local</span>               dd189a79766f32b8da90ff16a7cc4bf97ef662fcd9387e322232cd60de791a36
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>local</span>               go-microservices
</span></span></code></pre></div><p>查看全部数据卷信息</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker volume ls
</span></span><span style=display:flex><span><span style=color:#007f7f>#查看数据卷的详细信息，可以查询到存放的路径，创建时间等等</span>
</span></span><span style=display:flex><span>docker volume inspect 数据卷名称
</span></span></code></pre></div><p>删除指定的数据卷</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker volume rm 数据卷名称
</span></span></code></pre></div><p>容器映射数据卷通过数据卷名称映射，如果数据卷不存在。Docker会帮你自动创建，会将容器内部自带的文件，存储在默认的存放路径中。</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker run -v 数据卷名称:容器内部的路径 镜像id
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#通过路径映射数据卷，直接指定一个路径作为数据卷的存放位置。但是这个路径下是空的。手动添加内容，推荐这种方式</span>
</span></span><span style=display:flex><span>docker run -v 路径(<span style=color:#0ff;font-weight:700>/root/</span>自己创建的文件夹):容器内部的路径 镜像id
</span></span></code></pre></div><h3 id=dockerfile自定义镜像>Dockerfile自定义镜像</h3><p>创建自定义镜像就需要创建一个Dockerfiler,如下为Dockerfile的语言</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>from<span style=color:red>：</span>指定当前自定义镜像依赖的环境
</span></span><span style=display:flex><span>copy<span style=color:red>：</span>将相对路径下的内容复制到自定义镜像中
</span></span><span style=display:flex><span>workdir<span style=color:red>：</span>声明镜像的默认工作目录
</span></span><span style=display:flex><span>run<span style=color:red>：</span>执行的命令<span style=color:red>，</span>可以编写多个
</span></span><span style=display:flex><span>cmd<span style=color:red>：</span>需要执行的命令<span style=color:red>（</span>在workdir下执行的<span style=color:red>，</span>cmd可以写多个<span style=color:red>，</span>只以最后一个为准<span style=color:red>）</span>
</span></span></code></pre></div><p>生成镜像</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#007f7f>#编写完Dockerfile后需要通过命令将其制作为镜像，并且要在Dockerfile的当前目录下，之后即可在镜像中查看到指定的镜像信息</span>
</span></span><span style=display:flex><span><span style=color:#007f7f># 点意味着生成在当前目录下</span>
</span></span><span style=display:flex><span>docker build -t 镜像名称[:tag] .
</span></span></code></pre></div><h3 id=dockercompose>DockerCompose</h3><p>以上面的方式运行一个容器需要添加许多参数。为了更加的方便使用Docker-Compose编写配置文件把参数写进去。
Docker-Compose也可以批量的管理容器所以你只需要编写并维护一个docker-compose.yaml文件即可
地址
<a href=https://github.com/docker/compose>docker-compose</a>,可以在github的release下载已经打包好的</p><ul><li>Linux 环境</li></ul><p>下载好docker-compose然后将DockerCompose文件的名称修改一下，给予DockerCompose文件一个可执行的权限</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>mv docker-compose-Linux-x86_64 docker-compose
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>chmod</span> <span style=color:#ff0;font-weight:700>777</span> docker-compose
</span></span><span style=display:flex><span><span style=color:#007f7f>#方便后期操作，配置一个环境变量</span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#将docker-compose文件移动到了/usr/local/bin，修改了/etc/profile文件，给/usr/local/bin配置到了PATH中</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mv docker-compose <span style=color:#0ff;font-weight:700>/usr/</span><span style=color:#fff;font-weight:700>local</span>/bin
</span></span><span style=display:flex><span>vi <span style=color:#0ff;font-weight:700>/etc/</span>profile
</span></span><span style=display:flex><span><span style=color:#007f7f>#添加内容：export PATH=/usr/local/bin:$PATH</span>
</span></span><span style=display:flex><span>source <span style=color:#0ff;font-weight:700>/etc/</span>profile
</span></span><span style=display:flex><span><span style=color:#007f7f>#测试</span>
</span></span><span style=display:flex><span>docker-compose -v
</span></span></code></pre></div><ul><li>Mac 下如果你安装过了docker for mac app就可以直接使用了</li></ul><h3 id=dockercompose-管理>DockerCompose 管理</h3><p>编写docker-compose.yml文件yml文件以key:value方式来指定配置信息
多个配置信息以换行+缩进的方式来区分在docker-compose.yml文件中，不要使用制表符</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=font-weight:700>version</span>: <span style=color:#0ff;font-weight:700>&#39;3.1&#39;</span>
</span></span><span style=display:flex><span><span style=font-weight:700>services</span>:
</span></span><span style=display:flex><span>  <span style=font-weight:700>mysql</span>:           <span style=color:#007f7f># 服务的名称</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>restart</span>: always   <span style=color:#007f7f># 代表只要docker启动，那么这个容器就跟着一起启动</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>image</span>: daocloud.io/library/mysql:5.7.4  <span style=color:#007f7f># 指定镜像路径</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>container_name</span>: mysql  <span style=color:#007f7f># 指定容器名称 docker ps 看到的名称</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ff0;font-weight:700>3309</span>:<span style=color:#ff0;font-weight:700>3306</span>   <span style=color:#007f7f>#  指定端口号的映射</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>environment</span>:
</span></span><span style=display:flex><span>      <span style=font-weight:700>MYSQL_ROOT_PASSWORD</span>: root   <span style=color:#007f7f># 指定MySQL的ROOT用户登录密码</span>
</span></span><span style=display:flex><span>      <span style=font-weight:700>TZ</span>: Asia/Shanghai        <span style=color:#007f7f># 指定时区</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>volumes</span>:
</span></span><span style=display:flex><span>     - ~/docker_mysql/mysql_data:/var/lib/mysql   <span style=color:#007f7f># 映射数据卷</span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>go</span>:
</span></span><span style=display:flex><span>    <span style=font-weight:700>restart</span>: always
</span></span><span style=display:flex><span>    <span style=font-weight:700>image</span>: go:1.14.7
</span></span><span style=display:flex><span>    <span style=font-weight:700>container_name</span>: go
</span></span><span style=display:flex><span>    <span style=font-weight:700>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ff0;font-weight:700>8080</span>:<span style=color:#ff0;font-weight:700>8080</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>environment</span>:
</span></span><span style=display:flex><span>      <span style=font-weight:700>TZ</span>: Asia/Shanghai
</span></span><span style=display:flex><span>    <span style=font-weight:700>volumes</span>:
</span></span><span style=display:flex><span>      <span style=color:#007f7f>#填数据卷</span>
</span></span><span style=display:flex><span>  <span style=color:#007f7f>#如果还有镜像容器可以一直往下写</span>
</span></span></code></pre></div><h3 id=dockercompose-命令>DockerCompose 命令</h3><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>在使用docker-compose的命令时，默认会在当前目录下找docker-compose.yml文件
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#007f7f>#1.基于docker-compose.yml启动管理的容器</span>
</span></span><span style=display:flex><span>docker-compose up -d
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#007f7f>#2.关闭并删除容器</span>
</span></span><span style=display:flex><span>docker-compose down
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#007f7f>#3.开启|关闭|重启已经存在的由docker-compose维护的容器</span>
</span></span><span style=display:flex><span>docker-compose start|stop|restart
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#007f7f>#4.查看由docker-compose管理的容器</span>
</span></span><span style=display:flex><span>docker-compose ps
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#007f7f>#5.查看日志</span>
</span></span><span style=display:flex><span>docker-compose logs -f
</span></span></code></pre></div><h3 id=dockercompos配合dockerfile一起使用>DockerCompos配合Dockerfile一起使用</h3><p>docker-compose配合Dockerfile使用，就可以使用docker-compose管理自定义的镜像，它会帮你build然后启动。更加方便</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=font-weight:700>version</span>: <span style=color:#0ff;font-weight:700>&#39;3.1&#39;</span>
</span></span><span style=display:flex><span><span style=font-weight:700>services</span>:
</span></span><span style=display:flex><span>  <span style=font-weight:700>ssm</span>:
</span></span><span style=display:flex><span>    <span style=font-weight:700>restart</span>: always
</span></span><span style=display:flex><span>    <span style=font-weight:700>build</span>:            <span style=color:#007f7f># 构建自定义镜像</span>
</span></span><span style=display:flex><span>      <span style=font-weight:700>context</span>: ../      <span style=color:#007f7f># 指定dockerfile文件的所在路径</span>
</span></span><span style=display:flex><span>      <span style=font-weight:700>dockerfile</span>: Dockerfile   <span style=color:#007f7f># 指定Dockerfile文件名称</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>image</span>: your_image_name:1.0.1 <span style=color:#007f7f>#指定你镜像的名称和版本</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>container_name</span>: 容器名称
</span></span><span style=display:flex><span>    <span style=font-weight:700>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ff0;font-weight:700>8081</span>:<span style=color:#ff0;font-weight:700>8080</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>environment</span>:
</span></span><span style=display:flex><span>      <span style=font-weight:700>TZ</span>: Asia/Shanghai
</span></span></code></pre></div><p>运行</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#007f7f>#可以直接基于docker-compose.yml以及Dockerfile文件构建的自定义镜像</span>
</span></span><span style=display:flex><span>docker-compose up -d
</span></span><span style=display:flex><span><span style=color:#007f7f># 如果自定义镜像不存在，会自动构建出自定义镜像，如果自定义镜像已经存在，会直接运行这个自定义镜像</span>
</span></span><span style=display:flex><span><span style=color:#007f7f>#重新构建自定义镜像</span>
</span></span><span style=display:flex><span>docker-compose build
</span></span><span style=display:flex><span><span style=color:#007f7f>#运行当前内容，并重新构建</span>
</span></span><span style=display:flex><span>docker-compose up -d --build
</span></span></code></pre></div></div></article></main><script src=https://utteranc.es/client.js repo=glepnir/glepnir.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></div><footer><hr><p id=social>Find me around the web:<br><a href=https://github.com/glepnir>GitHub</a>
|
<a href=https://space.bilibili.com/321783076>Bilibili</a></p><p class=copyright>Copyright © 2023
<a href=https://yupdo.org><strong>glepnir</strong></a>.
This work is licensed under the
<a href=http://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a> license.</p></footer></body></html>