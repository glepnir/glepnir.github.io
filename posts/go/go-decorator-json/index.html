<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>glepnir/posts/go/go-decorator-json/</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><link rel=stylesheet href=https://blog.neovim.pro/console-plus/css/terminal-0.7.2.min.css><link rel=stylesheet href=https://blog.neovim.pro/console-plus/css/animate-4.1.1.min.css><link rel=stylesheet href=https://blog.neovim.pro/console-plus/css/console.css><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><meta property="og:title" content="Go Decorator Json"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://blog.neovim.pro/posts/go/go-decorator-json/"><meta property="article:published_time" content="2022-09-06T16:40:33+08:00"><meta name=twitter:title content="Go Decorator Json"><meta name=twitter:description content="常见的处理Http Json的响应输出
日常开发处理业务的时候这一步是必不可少的,判断处理各种情况然后返回给前端，有时候需要写不少重复的代码
例如这样的。"></head><body class=terminal><div class=container><div class=terminal-nav><header class=terminal-logo><div class="logo terminal-prompt"><a href=https://blog.neovim.pro/ class="no-style site-name">glepnir</a>:~#
<a href=https://blog.neovim.pro/posts>posts</a>/<a href=https://blog.neovim.pro/posts/go>go</a>/<a href=https://blog.neovim.pro/posts/go/go-decorator-json>go-decorator-json</a>/</div></header><nav class=terminal-menu><ul vocab="https://schema.org/" typeof="BreadcrumbList"><li><a href=https://blog.neovim.pro/posts/ typeof="ListItem">posts/</a></li><li><a href=https://blog.neovim.pro/about/ typeof="ListItem">about/</a></li><li><a href=https://blog.neovim.pro/sponsor/ typeof="ListItem">sponsor/</a></li></ul></nav></div></div><div class="container animated zoomIn fast"><h1>Go Decorator Json</h1>Sep. 6, 2022<br><br><h2 id=常见的处理http-json的响应输出>常见的处理Http Json的响应输出</h2><p>日常开发处理业务的时候这一步是必不可少的,判断处理各种情况然后返回给前端，有时候需要写不少重复的代码
例如这样的。</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#fe8019>func</span> <span style=color:#fabd2f>main</span>() {
</span></span><span style=display:flex><span>	e <span style=color:#fe8019>:=</span> echo.<span style=color:#fabd2f>New</span>()
</span></span><span style=display:flex><span>	e.<span style=color:#fabd2f>GET</span>(<span style=color:#b8bb26>&#34;/user&#34;</span>, getUserData)
</span></span><span style=display:flex><span>	e.<span style=color:#fabd2f>GET</span>(<span style=color:#b8bb26>&#34;/article&#34;</span>, getArticleData)
</span></span><span style=display:flex><span>	e.<span style=color:#fabd2f>Start</span>(<span style=color:#b8bb26>&#34;:8080&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>func</span> <span style=color:#fabd2f>getUserData</span>(c echo.Context) <span style=color:#fabd2f>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#fe8019>return</span> c.<span style=color:#fabd2f>JSON</span>(code, <span style=color:#b8bb26>&#34;result interface&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>func</span> <span style=color:#fabd2f>getArticleData</span>(c echo.Context) <span style=color:#fabd2f>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#fe8019>return</span> c.<span style=color:#fabd2f>JSON</span>(code, <span style=color:#b8bb26>&#34;article interface&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述的例子呢很简单，echo框架写一个http服务这里与框架关系不大，任何框架甚至标准库这里的代码也是大同</p><p>小异的，没什么很大的差别。忽略掉业务逻辑只关注return这部分，从目前的代码来看好像看不出什么问题，但</p><p>是项目的业务是很多的，这部分代码你可能要重写很多遍。那就做了许多的无用功很低效了，所以优雅的封装这</p><p>里是很有必要的，那么方式不止一种这里使用装饰器模式，如果你有其他优雅的方式可以写在评论区一起交流。</p><h2 id=使用装饰器模式>使用装饰器模式</h2><p>首先通过观察handler函数同样的参数和返回值,进一步将它抽象定义一个新的类型<code>myHandler</code>。</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#fe8019>func</span> <span style=color:#fabd2f>getArticleData</span>(c echo.Context) <span style=color:#fabd2f>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#fe8019>return</span> c.<span style=color:#fabd2f>JSON</span>(code, <span style=color:#b8bb26>&#34;article interface&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>type</span> myHandler <span style=color:#fe8019>func</span>(c echo.Context) (<span style=color:#fabd2f>int</span>, <span style=color:#fe8019>interface</span>{})
</span></span></code></pre></div><p>那么处理逻辑的函数就会变得更加简单直接</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#928374;font-style:italic>// 业务状态编码: 1000 =&gt; success 10001 ==&gt; failed
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#fe8019>func</span> <span style=color:#fabd2f>getUserHandler</span>(c echo.Context) (<span style=color:#fabd2f>int</span>, <span style=color:#fe8019>interface</span>{}) {
</span></span><span style=display:flex><span>	result <span style=color:#fe8019>:=</span> <span style=color:#fe8019>map</span>[<span style=color:#fabd2f>string</span>]<span style=color:#fe8019>interface</span>{}{
</span></span><span style=display:flex><span>		<span style=color:#b8bb26>&#34;msg&#34;</span>: <span style=color:#b8bb26>&#34;success&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#b8bb26>&#34;data&#34;</span>: <span style=color:#fe8019>map</span>[<span style=color:#fabd2f>string</span>]<span style=color:#fe8019>interface</span>{}{
</span></span><span style=display:flex><span>			<span style=color:#b8bb26>&#34;name&#34;</span>: <span style=color:#b8bb26>&#34;admin&#34;</span>,
</span></span><span style=display:flex><span>			<span style=color:#b8bb26>&#34;age&#34;</span>:  <span style=color:#d3869b>50</span>,
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#fe8019>return</span> <span style=color:#d3869b>1000</span>, result
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>接下来使用装饰器，将业务逻辑的函数装饰一下。最终的目的是要将这个业务逻辑函数放入到路由里去也就是</p><p><code>e.Get("/users",装饰后)</code>,那么这里的第二个参数的类型是<code>echo.HandlerFunc</code>,gin框架标准库这里也是类似的</p><p>名称，所以装饰过后的东西必然要满足<code>echo.HandlerFunc</code>。所以我们返回一个函数参数是我们定义的新类型，</p><p>返回值就是<code>echo.HandlerFunc</code>,其实这里与写中间件的写法是类似的，无非是多加了一层和定义了一个新的类型</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#fe8019>func</span> <span style=color:#fabd2f>handler</span>() <span style=color:#fe8019>func</span>(m myHandler) echo.HandlerFunc {
</span></span><span style=display:flex><span>	<span style=color:#fe8019>return</span> <span style=color:#fe8019>func</span>(m myHandler) echo.HandlerFunc {
</span></span><span style=display:flex><span>		<span style=color:#fe8019>return</span> <span style=color:#fe8019>func</span>(c echo.Context) <span style=color:#fabd2f>error</span> {
</span></span><span style=display:flex><span>			code, result <span style=color:#fe8019>:=</span> <span style=color:#fabd2f>m</span>(c)
</span></span><span style=display:flex><span>			<span style=color:#fe8019>if</span> code <span style=color:#fe8019>==</span> <span style=color:#d3869b>1000</span> {
</span></span><span style=display:flex><span>				<span style=color:#fe8019>return</span> c.<span style=color:#fabd2f>JSON</span>(<span style=color:#d3869b>200</span>, result)
</span></span><span style=display:flex><span>			} <span style=color:#fe8019>else</span> {
</span></span><span style=display:flex><span>				<span style=color:#fe8019>return</span> c.<span style=color:#fabd2f>JSON</span>(<span style=color:#d3869b>400</span>, result)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><script src=https://utteranc.es/client.js repo=glepnir/glepnir.github.io issue-term=title theme=dark-blue crossorigin=anonymous async></script><div class=footer>Copyright © 2022 author glepnir</div></div></body></html>