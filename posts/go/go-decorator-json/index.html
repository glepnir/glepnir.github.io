<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><title>Go Decorator Json | glepnir</title><link rel=stylesheet href=/css/reset.css><link rel=stylesheet href=/css/font.css><link rel=stylesheet href=/css/smigle.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"></head><body><header><div id=brand><a class=icon-link href=https://yupdo.org><img class=icon src=/images/avatar.svg></a><div class=text><a href=https://yupdo.org><h1>glepnir</h1></a><h3>A vimer work at neovim team and other open source project.</h3></div></div><nav><a href=/><b>Home</b></a>
|
<a href=/posts/><b>Posts</b></a>
|
<a href=/donate/><b>Donate</b></a>
|
<a href=/categories/><b>Categories</b></a>
|
<a href=/tags/><b>Tags</b></a>
|
<a href=/about/><b>About</b></a></nav><hr></header><div id=content><main><article><h1>Go Decorator Json</h1><div class=post-meta><strong><span>Posted on</span>
<time>2022-09-06</time></strong>
<span>• 132 words</span>
<span>• 1 minute read</span><div><span>Tags:</span>
<a href=/tags/go>go</a></div></div><div><h2 id=常见的处理http-json的响应输出>常见的处理Http Json的响应输出</h2><p>日常开发处理业务的时候这一步是必不可少的,判断处理各种情况然后返回给前端，有时候需要写不少重复的代码
例如这样的。</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#fff;font-weight:700>func</span> main() {
</span></span><span style=display:flex><span>	e := echo.New()
</span></span><span style=display:flex><span>	e.GET(<span style=color:#0ff;font-weight:700>&#34;/user&#34;</span>, getUserData)
</span></span><span style=display:flex><span>	e.GET(<span style=color:#0ff;font-weight:700>&#34;/article&#34;</span>, getArticleData)
</span></span><span style=display:flex><span>	e.Start(<span style=color:#0ff;font-weight:700>&#34;:8080&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>func</span> getUserData(c echo.Context) <span style=color:#fff;font-weight:700>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> c.JSON(code, <span style=color:#0ff;font-weight:700>&#34;result interface&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>func</span> getArticleData(c echo.Context) <span style=color:#fff;font-weight:700>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> c.JSON(code, <span style=color:#0ff;font-weight:700>&#34;article interface&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述的例子呢很简单，echo框架写一个http服务这里与框架关系不大，任何框架甚至标准库这里的代码也是大同</p><p>小异的，没什么很大的差别。忽略掉业务逻辑只关注return这部分，从目前的代码来看好像看不出什么问题，但</p><p>是项目的业务是很多的，这部分代码你可能要重写很多遍。那就做了许多的无用功很低效了，所以优雅的封装这</p><p>里是很有必要的，那么方式不止一种这里使用装饰器模式，如果你有其他优雅的方式可以写在评论区一起交流。</p><h2 id=使用装饰器模式>使用装饰器模式</h2><p>首先通过观察handler函数同样的参数和返回值,进一步将它抽象定义一个新的类型<code>myHandler</code>。</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#fff;font-weight:700>func</span> getArticleData(c echo.Context) <span style=color:#fff;font-weight:700>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> c.JSON(code, <span style=color:#0ff;font-weight:700>&#34;article interface&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>type</span> myHandler <span style=color:#fff;font-weight:700>func</span>(c echo.Context) (<span style=color:#fff;font-weight:700>int</span>, <span style=color:#fff;font-weight:700>interface</span>{})
</span></span></code></pre></div><p>那么处理逻辑的函数就会变得更加简单直接</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#007f7f>// 业务状态编码: 1000 =&gt; success 10001 ==&gt; failed
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>func</span> getUserHandler(c echo.Context) (<span style=color:#fff;font-weight:700>int</span>, <span style=color:#fff;font-weight:700>interface</span>{}) {
</span></span><span style=display:flex><span>	result := <span style=color:#fff;font-weight:700>map</span>[<span style=color:#fff;font-weight:700>string</span>]<span style=color:#fff;font-weight:700>interface</span>{}{
</span></span><span style=display:flex><span>		<span style=color:#0ff;font-weight:700>&#34;msg&#34;</span>: <span style=color:#0ff;font-weight:700>&#34;success&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#0ff;font-weight:700>&#34;data&#34;</span>: <span style=color:#fff;font-weight:700>map</span>[<span style=color:#fff;font-weight:700>string</span>]<span style=color:#fff;font-weight:700>interface</span>{}{
</span></span><span style=display:flex><span>			<span style=color:#0ff;font-weight:700>&#34;name&#34;</span>: <span style=color:#0ff;font-weight:700>&#34;admin&#34;</span>,
</span></span><span style=display:flex><span>			<span style=color:#0ff;font-weight:700>&#34;age&#34;</span>:  <span style=color:#ff0;font-weight:700>50</span>,
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>1000</span>, result
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>接下来使用装饰器，将业务逻辑的函数装饰一下。最终的目的是要将这个业务逻辑函数放入到路由里去也就是</p><p><code>e.Get("/users",装饰后)</code>,那么这里的第二个参数的类型是<code>echo.HandlerFunc</code>,gin框架标准库这里也是类似的</p><p>名称，所以装饰过后的东西必然要满足<code>echo.HandlerFunc</code>。所以我们返回一个函数参数是我们定义的新类型，</p><p>返回值就是<code>echo.HandlerFunc</code>,其实这里与写中间件的写法是类似的，无非是多加了一层和定义了一个新的类型</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#fff;font-weight:700>func</span> handler() <span style=color:#fff;font-weight:700>func</span>(m myHandler) echo.HandlerFunc {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#fff;font-weight:700>func</span>(m myHandler) echo.HandlerFunc {
</span></span><span style=display:flex><span>		<span style=color:#fff;font-weight:700>return</span> <span style=color:#fff;font-weight:700>func</span>(c echo.Context) <span style=color:#fff;font-weight:700>error</span> {
</span></span><span style=display:flex><span>			code, result := m(c)
</span></span><span style=display:flex><span>			<span style=color:#fff;font-weight:700>if</span> code == <span style=color:#ff0;font-weight:700>1000</span> {
</span></span><span style=display:flex><span>				<span style=color:#fff;font-weight:700>return</span> c.JSON(<span style=color:#ff0;font-weight:700>200</span>, result)
</span></span><span style=display:flex><span>			} <span style=color:#fff;font-weight:700>else</span> {
</span></span><span style=display:flex><span>				<span style=color:#fff;font-weight:700>return</span> c.JSON(<span style=color:#ff0;font-weight:700>400</span>, result)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></article></main><script src=https://utteranc.es/client.js repo=glepnir/glepnir.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></div><footer><hr><p id=social>Find me around the web:<br><a href=https://github.com/glepnir>GitHub</a>
|
<a href=https://space.bilibili.com/321783076>Bilibili</a></p><p class=copyright>Copyright © 2023
<a href=https://yupdo.org><strong>glepnir</strong></a>.
This work is licensed under the
<a href=http://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a> license.</p></footer></body></html>