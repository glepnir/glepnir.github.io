[{"categories":[],"contents":"Last week, I was staring at two pieces of code a friend had sent me, asking which one I preferred. They looked like this:\n// Version A double calculate_mean(const vector\u0026lt;double\u0026gt;\u0026amp; data) { double sum = 0.0; for (const auto\u0026amp; x : data) { sum += x; } return sum / data.size(); } // Version B double calculate_stddev(const vector\u0026lt;double\u0026gt;\u0026amp; data) { double sum = 0.0; double mean = calculate_mean(data); for (const auto\u0026amp; x : data) { sum += (x - mean) * (x - mean); } return sqrt(sum / data.size()); } I looked at them for a solid five seconds before it hit me: these two loops were fundamentally the same mathematical pattern! But in the code, that pattern was buried under for loops and accumulation variables.\nSeeing with Math Eyes In math, we\u0026rsquo;d write these calculations as:\nmean=1nâˆ‘i=1nxi \\text{mean} = \\frac{1}{n} \\sum_{i=1}^n x_i mean=n1â€‹i=1âˆ‘nâ€‹xiâ€‹stddev=1nâˆ‘i=1n(xiâˆ’Î¼)2 \\text{stddev} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2} stddev=n1â€‹i=1âˆ‘nâ€‹(xiâ€‹âˆ’Î¼)2â€‹See that $\\sum$ symbol? That\u0026rsquo;s our abstraction point. In functional programming, this is called a fold (or reduce), defined as:\nfold(f,z,[x1,x2,...,xn])=f(f(f(z,x1),x2),...,xn) \\text{fold}(f, z, [x_1, x_2, ..., x_n]) = f(f(f(z, x_1), x_2), ..., x_n) fold(f,z,[x1â€‹,x2â€‹,...,xnâ€‹])=f(f(f(z,x1â€‹),x2â€‹),...,xnâ€‹)Looking at my code with this new perspective:\ntemplate\u0026lt;typename T, typename BinaryOp\u0026gt; T fold(const vector\u0026lt;T\u0026gt;\u0026amp; vec, T init, BinaryOp op) { T result = init; for (const auto\u0026amp; x : vec) { result = op(result, x); } return result; } Now both calculations become:\ndouble mean = fold(data, 0.0, plus\u0026lt;double\u0026gt;{}) / data.size(); double variance = fold(data, 0.0, [mean](double acc, double x) { return acc + (x - mean) * (x - mean); }) / data.size(); The Real Breakthrough: Seeing Deeper Patterns I started noticing this pattern everywhere. Take this convex hull algorithm I\u0026rsquo;d written:\nvector\u0026lt;Point\u0026gt; find_convex_hull(const vector\u0026lt;Point\u0026gt;\u0026amp; points) { vector\u0026lt;Point\u0026gt; hull; for (size_t i = 0; i \u0026lt; points.size(); ++i) { for (size_t j = 0; j \u0026lt; points.size(); ++j) { if (i == j) continue; bool all_on_same_side = true; for (size_t k = 0; k \u0026lt; points.size(); ++k) { if (k == i || k == j) continue; if (!is_on_same_side(points[i], points[j], points[k])) { all_on_same_side = false; break; } } if (all_on_same_side) { hull.push_back(points[i]); hull.push_back(points[j]); } } } return remove_duplicates(hull); } Three nested loops! But with functional thinking, I saw predicate logic:\nA point pair (i,j) belongs to the convex hull boundary if and only if all other points are on the same side of the line segment (i,j).\nMathematically: (i,j)âˆˆhullâ€…âŸºâ€…âˆ€kâ‰ i,j:same_side(i,j,k) (i,j) \\in \\text{hull} \\iff \\forall k \\neq i,j : \\text{same\\_side}(i,j,k) (i,j)âˆˆhullâŸºâˆ€kî€ =i,j:same_side(i,j,k)In C++, this becomes:\nvector\u0026lt;Point\u0026gt; find_convex_hull_fp(const vector\u0026lt;Point\u0026gt;\u0026amp; points) { auto pairs = cartesian_product(points, points); auto is_hull_edge = [\u0026amp;](const pair\u0026lt;Point, Point\u0026gt;\u0026amp; edge) { return all_of(points.begin(), points.end(), [\u0026amp;](const Point\u0026amp; p) { return \u0026amp;p == \u0026amp;edge.first || \u0026amp;p == \u0026amp;edge.second || is_on_same_side(edge.first, edge.second, p); }); }; return filter(pairs, is_hull_edge) | transform([](auto\u0026amp;\u0026amp; p) { return vector{p.first, p.second}; }) | flatten() | unique(); } Why This Matters: You Can Actually Prove Things Here\u0026rsquo;s the cool part: functional code is easier to reason about.\nWith the original code, proving correctness meant:\nTracking three loop variables Understanding when the break happens Verifying when hull gets updated With the functional version:\ncartesian_product generates all point pairs (obvious) is_hull_edge is a direct translation of the mathematical definition The composition uses standard, well-understood operations I can even write tests that verify mathematical properties:\n// Convex hull property: all points should be inside the hull TEST(ConvexHull, AllPointsInsideHull) { auto points = generate_random_points(100); auto hull = find_convex_hull_fp(points); for (const auto\u0026amp; p : points) { ASSERT_TRUE(is_point_inside_convex_polygon(p, hull)); } } Category Theory Sneaks In Recently, I was writing a config parser with multiple operations that could fail:\noptional\u0026lt;int\u0026gt; parse_timeout(const string\u0026amp; str); optional\u0026lt;string\u0026gt; parse_hostname(const string\u0026amp; str); optional\u0026lt;Config\u0026gt; create_config(int timeout, const string\u0026amp; host); The traditional way:\noptional\u0026lt;Config\u0026gt; parse_config(const string\u0026amp; timeout_str, const string\u0026amp; host_str) { auto timeout = parse_timeout(timeout_str); if (!timeout) return nullopt; auto host = parse_hostname(host_str); if (!host) return nullopt; return create_config(*timeout, *host); } The functional way uses a pattern (some people call it a monad, but I just call it useful):\ntemplate\u0026lt;typename T, typename Func\u0026gt; auto and_then(const optional\u0026lt;T\u0026gt;\u0026amp; opt, Func f) -\u0026gt; decltype(f(opt.value())) { if (!opt) return decltype(f(opt.value()))(); return f(*opt); } optional\u0026lt;Config\u0026gt; parse_config_fp(const string\u0026amp; timeout_str, const string\u0026amp; host_str) { return and_then(parse_timeout(timeout_str), [\u0026amp;](int timeout) { return and_then(parse_hostname(host_str), [\u0026amp;](const string\u0026amp; host) { return create_config(timeout, host); }); }); } Mathematically, this is composition in the Kleisli category: f:Aâ†’M(B),g:Bâ†’M(C)gâˆ˜Kf:Aâ†’M(C) f: A \\to M(B), \\quad g: B \\to M(C) \\\\ g \\circ_K f: A \\to M(C) f:Aâ†’M(B),g:Bâ†’M(C)gâˆ˜Kâ€‹f:Aâ†’M(C)Performance? Actually Better People say functional code is slow. Modern C++ compilers are smart:\n// Hand-written \u0026#34;optimized\u0026#34; version double sum_squares(const vector\u0026lt;double\u0026gt;\u0026amp; data) { double sum = 0.0; for (const auto\u0026amp; x : data) { sum += x * x; } return sum; } // Functional version double sum_squares_fp(const vector\u0026lt;double\u0026gt;\u0026amp; data) { return fold(data, 0.0, [](double acc, double x) { return acc + x * x; }); } With -O3, GCC generates identical assembly for both. The functional version is actually saferâ€”no loop variables, no bounds checking worries.\nMy New Toolkit Here\u0026rsquo;s what functional thinking added to my C++ toolbox:\nmap/filter/reduce - The basics for working with collections Function composition - compose(f, g)(x) = f(g(x)) Currying - curry(f)(a)(b) = f(a, b) Lazy evaluation - Using generator or ranges::view Like currying for configuration:\nauto create_server = curry([](int port, const string\u0026amp; host, Config config) { return Server{port, host, config}; }); auto create_local_server = create_server(8080, \u0026#34;localhost\u0026#34;); auto server = create_local_server(config); The Mindset Shift Functional programming taught me something important: code is math, and the compiler is my proof assistant.\nBefore: I wrote loops thinking \u0026ldquo;do this repeatedly\u0026rdquo;. Now: I write fold thinking \u0026ldquo;apply this associative operation\u0026rdquo;.\nBefore: I wrote conditionals thinking \u0026ldquo;if this, then that\u0026rdquo;. Now: I write filter thinking \u0026ldquo;select elements satisfying this predicate\u0026rdquo;.\nThis mindset lets me write code that\u0026rsquo;s easier to prove correct. Last week I found a bug and mentally traced it:\nGiven: filter(is_even, [1,2,3,4]) = [2,4] Given: map(square, [2,4]) = [4,16] Given: fold(add, 0, [4,16]) = 20 Therefore: sum of squares of even numbers = 20 Writing it down like that was the proof.\nFunctional C++ in the Real World This is how I write production code now:\n// HTTP request processing pipeline auto handle_request = compose( validate_request, authenticate, parse_body\u0026lt;Order\u0026gt;, process_order, create_response ); // Or with ranges auto valid_orders = requests | views::filter(is_valid_order) | views::transform(parse_order) | views::filter([](const Order\u0026amp; o) { return o.total \u0026gt; 100.0; }) | views::transform(apply_discount) | ranges::to\u0026lt;vector\u0026gt;(); This isn\u0026rsquo;t \u0026ldquo;functional C++\u0026quot;â€”it\u0026rsquo;s just C++. But it\u0026rsquo;s C++ written with functional thinking.\nFinally When I started seeing loops through mathematical eyes, they stopped being loops and became instances of algebraic structures. That perspective lets me write code that\u0026rsquo;s cleaner, more correct, and honestly more fun to write.\nMaybe that\u0026rsquo;s the end goal of programming: code stops being instructions and becomes executable mathematics.\n","date":"2025-12-27","permalink":"https://www.functor.me/posts/thought_fp/","section":"","summary":"","tags":[],"title":"When Loops Become Math: How Functional Thinking Changed My C++"},{"categories":[],"contents":"I\u0026rsquo;ve probably made some different Neovim themes over the years. Each time I thought \u0026ldquo;this is the one\u0026rdquo; and each time, a month later, I\u0026rsquo;d be tweaking colors again because something just felt\u0026hellip; off.\nThe problem? I was doing what everyone doesâ€”picking colors by eye, converting between RGB and HSL, hoping the math would somehow make sense. Spoiler: it doesn\u0026rsquo;t.\nThen I found Oklab and everything got way easier.\nRGB/HSL Are Kinda Broken for This Here\u0026rsquo;s the thing: in RGB, changing red from 200 to 210 might look like a tiny shift, but changing blue from 200 to 210 could be a massive difference. HSL is better but still weirdâ€”adjusting saturation can make some colors way brighter and others barely change.\nYou end up with this:\n-- Wait, which one is brighter? ðŸ¤· local color1 = \u0026#34;#c5895b\u0026#34; local color2 = \u0026#34;#a87d52\u0026#34; No idea without actually looking at them. And if you want to make color1 \u0026ldquo;just a bit dimmer\u0026rdquo;? Good luck.\nEnter Oklab: Colors That Actually Make Sense Oklab is a \u0026ldquo;perceptually uniform\u0026rdquo; color space. Translation: move a color 0.1 units and it looks 0.1 units different. Predictably.\nIt has three channels:\nL (0-1): Brightness. 0 = black, 1 = white, simple. a (-0.4 to +0.4): Red â†” Green b (-0.4 to +0.4): Yellow â†” Blue Want an orange that\u0026rsquo;s 68% bright? Easy:\noklab_to_srgb(0.68, 0.055, 0.065) -- L=0.68, slightly red, slightly yellow = orange Want it brighter? Change the first number:\noklab_to_srgb(0.72, 0.055, 0.065) -- Same hue, 4% brighter That\u0026rsquo;s it. No guessing.\nThe Math The conversion from Oklab to RGB goes through a few steps:\nStep 1: Oklab â†’ LMS (cone response) [lms]=[10.39630.21581âˆ’0.1056âˆ’0.06391âˆ’0.0895âˆ’1.2915][Lab] \\begin{bmatrix} l \\\\ m \\\\ s \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 0.3963 \u0026amp; 0.2158 \\\\ 1 \u0026amp; -0.1056 \u0026amp; -0.0639 \\\\ 1 \u0026amp; -0.0895 \u0026amp; -1.2915 \\end{bmatrix} \\begin{bmatrix} L \\\\ a \\\\ b \\end{bmatrix} â€‹lmsâ€‹â€‹=â€‹111â€‹0.3963âˆ’0.1056âˆ’0.0895â€‹0.2158âˆ’0.0639âˆ’1.2915â€‹â€‹â€‹Labâ€‹â€‹Step 2: Inverse cube root LMSlinear=[l3,m3,s3]T \\text{LMS}_{\\text{linear}} = [l^3, m^3, s^3]^T LMSlinearâ€‹=[l3,m3,s3]TStep 3: LMS â†’ Linear RGB [RGB]=[4.0767âˆ’3.30770.2310âˆ’1.26842.6098âˆ’0.3413âˆ’0.0042âˆ’0.70341.7076][l3m3s3] \\begin{bmatrix} R \\\\ G \\\\ B \\end{bmatrix} = \\begin{bmatrix} 4.0767 \u0026amp; -3.3077 \u0026amp; 0.2310 \\\\ -1.2684 \u0026amp; 2.6098 \u0026amp; -0.3413 \\\\ -0.0042 \u0026amp; -0.7034 \u0026amp; 1.7076 \\end{bmatrix} \\begin{bmatrix} l^3 \\\\ m^3 \\\\ s^3 \\end{bmatrix} â€‹RGBâ€‹â€‹=â€‹4.0767âˆ’1.2684âˆ’0.0042â€‹âˆ’3.30772.6098âˆ’0.7034â€‹0.2310âˆ’0.34131.7076â€‹â€‹â€‹l3m3s3â€‹â€‹Step 4: Gamma correction (sRGB) CsRGB={12.92Ã—ClinearifÂ Clinearâ‰¤0.00313081.055Ã—Clinear1/2.4âˆ’0.055otherwise C_{\\text{sRGB}} = \\begin{cases} 12.92 \\times C_{\\text{linear}} \u0026amp; \\text{if } C_{\\text{linear}} \\leq 0.0031308 \\\\ 1.055 \\times C_{\\text{linear}}^{1/2.4} - 0.055 \u0026amp; \\text{otherwise} \\end{cases} CsRGBâ€‹={12.92Ã—Clinearâ€‹1.055Ã—Clinear1/2.4â€‹âˆ’0.055â€‹ifÂ Clinearâ€‹â‰¤0.0031308otherwiseâ€‹Here\u0026rsquo;s the implementation:\nlocal function oklab_to_linear_rgb(L, a, b) -- Transform Oklab to LMS (cone response) local l = L + 0.3963377774 * a + 0.2158037573 * b local m = L - 0.1055613458 * a - 0.0638541728 * b local s = L - 0.0894841775 * a - 1.2914855480 * b -- Apply inverse cube root local l3, m3, s3 = l * l * l, m * m * m, s * s * s -- LMS to linear RGB local r = 4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3 local g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3 local b_out = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3 return r, g, b_out end local function linear_to_srgb_component(c) if c \u0026lt;= 0.0031308 then return c * 12.92 else return 1.055 * (c ^ (1 / 2.4)) - 0.055 end end local function oklab_to_srgb(L, a, b) local r, g, b_comp = oklab_to_linear_rgb(L, a, b) r = linear_to_srgb_component(r) g = linear_to_srgb_component(g) b_comp = linear_to_srgb_component(b_comp) -- Convert to 8-bit and clamp r = math.floor(math.max(0, math.min(1, r)) * 255 + 0.5) g = math.floor(math.max(0, math.min(1, g)) * 255 + 0.5) b_comp = math.floor(math.max(0, math.min(1, b_comp)) * 255 + 0.5) return string.format(\u0026#39;#%02x%02x%02x\u0026#39;, r, g, b_comp) end Those magic numbers come from the Oklab spec. Just copy-paste and it works.\nDesigning a Palette Here\u0026rsquo;s how I actually use this. Instead of random hex codes, I think in terms of brightness and hue.\nBackground and foreground first:\nlocal colors = {} -- Dark but not pure black (L=0.24, basically neutral) colors.bg = oklab_to_srgb(0.24, 0.001, 0.006) -- Bright text (L=0.74, also basically neutral) colors.fg = oklab_to_srgb(0.74, 0.0, 0.008) Then decide on a brightness hierarchy.\nThere are two common approaches:\nStyle 1: Data-First (Tonsky\u0026rsquo;s philosophy)\nDim keywords (low brightness + low saturation) - they\u0026rsquo;re just syntactic noise Brighten function definitions, strings, numbers - that\u0026rsquo;s your actual code Example: keywords at L=0.60, data at L=0.68-0.70 Style 2: Structure-First\nBrighten keywords, functions, types - emphasize code structure Dim data (strings, numbers) - they\u0026rsquo;re secondary Example: structure at L=0.68, data at L=0.64 See the \u0026ldquo;Putting It Together\u0026rdquo; section below for concrete examples of both styles.\nHow to Pick a/b Values (Hue) Here\u0026rsquo;s a quick reference for common colors in Oklab space:\n-- Red: a \u0026gt; 0, b near 0 or slightly positive oklab_to_srgb(L, 0.08, 0.04) -- orange-red oklab_to_srgb(L, 0.10, 0.02) -- pure red oklab_to_srgb(L, 0.10, -0.02) -- magenta-red -- Orange: a \u0026gt; 0, b \u0026gt; 0, roughly equal oklab_to_srgb(L, 0.055, 0.065) -- typical orange oklab_to_srgb(L, 0.05, 0.07) -- more yellow-orange -- Yellow: a â‰ˆ 0, b \u0026gt; 0 oklab_to_srgb(L, 0.02, 0.08) -- yellow-orange oklab_to_srgb(L, 0.0, 0.08) -- pure yellow oklab_to_srgb(L, -0.02, 0.08) -- yellow-green -- Green: a \u0026lt; 0, b \u0026gt; 0 oklab_to_srgb(L, -0.05, 0.06) -- typical green oklab_to_srgb(L, -0.08, 0.04) -- deeper green -- Cyan: a \u0026lt; 0, b \u0026lt; 0, |a| \u0026gt; |b| oklab_to_srgb(L, -0.055, -0.01) -- cyan oklab_to_srgb(L, -0.06, -0.03) -- more blue-cyan -- Blue: a \u0026lt; 0, b \u0026lt; 0, |b| \u0026gt; |a| oklab_to_srgb(L, -0.02, -0.06) -- typical blue oklab_to_srgb(L, -0.01, -0.08) -- deeper blue -- Violet/Purple: a \u0026gt; 0, b \u0026lt; 0 oklab_to_srgb(L, 0.05, -0.04) -- violet oklab_to_srgb(L, 0.08, -0.06) -- purple Saturation control: saturation=a2+b2\\text{saturation} = \\sqrt{a^2 + b^2}saturation=a2+b2â€‹\ns \u0026lt; 0.05: very muted, almost gray s â‰ˆ 0.08: moderate, comfortable for long sessions s \u0026gt; 0.10: vivid, can be fatiguing So if you want a \u0026ldquo;medium orange at 68% brightness with moderate saturation around 0.08\u0026rdquo;:\n-- Start with the hue ratio you want (orange â‰ˆ equal a and b) -- Then scale to get saturation â‰ˆ 0.08 local orange = oklab_to_srgb(0.68, 0.055, 0.065) -- sqrt(0.055Â² + 0.065Â²) â‰ˆ 0.085 Blending Colors Sometimes you need a subtle background colorâ€”like for diagnostic messages. You want it to be related to the error color but way more subtle.\nHere\u0026rsquo;s my blend function:\nlocal function hex_to_rgb(hex) hex = hex:gsub(\u0026#39;#\u0026#39;, \u0026#39;\u0026#39;) return { tonumber(hex:sub(1, 2), 16), tonumber(hex:sub(3, 4), 16), tonumber(hex:sub(5, 6), 16), } end local function rgb_to_hex(c) return string.format(\u0026#39;#%02x%02x%02x\u0026#39;, c[1], c[2], c[3]) end local function blend(fg, t) local a, b = hex_to_rgb(fg), hex_to_rgb(colors.bg) local c = { math.floor(a[1] * (1 - t) + b[1] * t + 0.5), math.floor(a[2] * (1 - t) + b[2] * t + 0.5), math.floor(a[3] * (1 - t) + b[3] * t + 0.5), } return rgb_to_hex(c) end Use it like this:\n-- Red error text on a very subtle reddish background h(\u0026#39;DiagnosticVirtualTextError\u0026#39;, { fg = colors.red, bg = blend(colors.red, 0.65) -- 65% background, 35% red }) The t parameter controls the mix. 0.0 = pure foreground color, 1.0 = pure background, 0.65 = mostly background with a hint of the foreground.\nThis is way better than manually picking a \u0026ldquo;light red\u0026rdquo; background that might not even match.\nPutting It Together Just some quick examples of how to use this:\n-- Make a few colors local orange = oklab_to_srgb(0.68, 0.055, 0.065) local blue = oklab_to_srgb(0.68, -0.02, -0.06) local green = oklab_to_srgb(0.64, -0.05, 0.06) local red = oklab_to_srgb(0.66, 0.08, 0.04) -- Use them vim.api.nvim_set_hl(0, \u0026#39;Keyword\u0026#39;, { fg = orange }) vim.api.nvim_set_hl(0, \u0026#39;Function\u0026#39;, { fg = blue }) vim.api.nvim_set_hl(0, \u0026#39;String\u0026#39;, { fg = green }) vim.api.nvim_set_hl(0, \u0026#39;DiagnosticError\u0026#39;, { fg = red }) -- Blend for subtle backgrounds vim.api.nvim_set_hl(0, \u0026#39;DiagnosticVirtualTextError\u0026#39;, { bg = blend(red, 0.65) }) That\u0026rsquo;s pretty much it. Pick some L values, tweak the a/b until it looks right, done.\nWhy This Actually Helps Before Oklab:\n\u0026ldquo;This orange looks too bright\u0026hellip; let me try #c58960\u0026hellip; no wait #b87a55\u0026hellip; hmm maybe #ca8e62?\u0026rdquo; One hour later, still tweaking After Oklab:\n\u0026ldquo;Too bright? Change L from 0.68 to 0.65\u0026rdquo; Done in 30 seconds The real win is systematic adjustments:\nMake everything 5% brighter? Add 0.05 to all L values Reduce saturation? Scale down all a/b values by 20% Switch from data-first to structure-first? Just swap the L values You\u0026rsquo;re not guessing anymore. You\u0026rsquo;re tuning a system.\nSome Practical Tips Testing colors quickly:\nlocal test = oklab_to_srgb(0.68, 0.055, 0.065) print(test) -- prints: #c5895b Adjusting systematically:\n-- Make everything 5% brighter colors.orange = oklab_to_srgb(0.73, 0.055, 0.065) -- was 0.68 -- Reduce saturation by 20% colors.orange = oklab_to_srgb(0.68, 0.044, 0.052) -- was (0.055, 0.065) -- Warm up the whole palette colors.orange = oklab_to_srgb(0.68, 0.055, 0.075) -- increase b value When not to use Oklab: If you\u0026rsquo;re trying to match an existing hex code exactly, just use the hex. Oklab is for designing colors, not copying them.\nReferences Oklab spec: https://bottosson.github.io/posts/oklab/ (this is where all those magic numbers come from) That\u0026rsquo;s it. No need to make this more complicated than it is. Pick some L values for brightness, tweak a/b until the hues look right, and you\u0026rsquo;re done.\n","date":"2025-12-24","permalink":"https://www.functor.me/posts/oklab_design/","section":"","summary":"","tags":["","",""],"title":"Stop Guessing Hex Codes: A Better Way to Pick Theme Colors"}]