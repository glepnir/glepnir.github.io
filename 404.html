<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png }><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content="404 Page not found"><title>404 Page not found | glepnir's blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.0e9c0bb0a7de7a330263937778a4d7c0d0c6be7f327c69a0223c9f2fd31e00d5.css media=all></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/><u>H</u>ome</a></li><li><a tabindex=-1 class=menu-link href=/tags><u>T</u>ags</a></li></ul></nav>404 NOT FOUND<br><footer class=site-footer><p class=footer-meta>© 2025 glepnir ·
<a href=https://github.com/glepnir>GitHub</a> ·
<a href=https://reddit.com/u/glephunter>Reddit</a> ·
<a href=https://www.functor.me/index.xml>RSS</a></p><script defer>document.addEventListener("keydown",function(e){if(document.activeElement.isContentEditable)return!1;if(document.activeElement.tagName=="INPUT")return!1;if(e.altKey||e.ctrlKey||e.shiftKey)return!1;var t=e.key;if(t==="h")e.preventDefault(),e.stopPropagation(),window.location.href="/";else if(t==="t")e.preventDefault(),e.stopPropagation(),window.location.href=`https://${location.hostname}/tags`;else if(t==="i"){e.preventDefault(),e.stopPropagation();const t=document.querySelectorAll("input");for(let e=0;e<t.length;e++)if(t[e].offsetParent!==null){t[e].selectionStart=t[e].selectionEnd=t[e].value.length,t[e].focus();break}}return!1})</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,200))}setTimeout(scrollHandler,100)</script><script defer>function getTextContentRecursively(e){let t="";if(e.nodeType===Node.TEXT_NODE)return e.textContent||"";for(const n of e.childNodes)t+=getTextContentRecursively(n);return t}function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]:not(.output):not([class*="language-console"])');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const n=getTextContentRecursively(e);navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script>window.store={"https://www.functor.me/tags/color-science/":{title:"Color-Science",tags:[],content:"",url:"https://www.functor.me/tags/color-science/"},"https://www.functor.me/":{title:"glepnir's blog",tags:[],content:"",url:"https://www.functor.me/"},"https://www.functor.me/tags/neovim/":{title:"Neovim",tags:[],content:"",url:"https://www.functor.me/tags/neovim/"},"https://www.functor.me/tags/oklab/":{title:"Oklab",tags:[],content:"",url:"https://www.functor.me/tags/oklab/"},"https://www.functor.me/posts/":{title:"Posts",tags:[],content:"",url:"https://www.functor.me/posts/"},"https://www.functor.me/tags/":{title:"Tags",tags:[],content:"",url:"https://www.functor.me/tags/"},"https://www.functor.me/posts/colorscheme/":{title:"The Best Theme Isn't the Prettiest—It's the One You Forget Exists",tags:["neovim","color-science","vision-research","oklab"],content:`Over the past few years, I&rsquo;ve created numerous Neovim color schemes. My workflow was always the same: pick an existing theme, adjust its colors in HSL space until they felt comfortable, and use it for a while. But invariably, after several weeks or months, the same pattern emerged—visual fatigue. My eyes would tire faster during long coding sessions, colors that once felt &ldquo;right&rdquo; started to irritate, and I&rsquo;d find myself tweaking values again and again.
The cycle was frustrating: find theme → adjust → use → fatigue → repeat. Each iteration felt arbitrary. I was working blind, relying purely on subjective perception without understanding why certain colors caused fatigue and others didn&rsquo;t.
This is the story of how I broke that cycle by building a color scheme from scientific first principles.
The Insight: Color Science Exists for a Reason The breakthrough came when I realized: vision scientists have spent decades studying exactly these problems. Research exists on:
How the human eye perceives contrast (Contrast Sensitivity Function) Which color spaces are perceptually uniform (Oklab, CIELAB) What causes color-induced visual fatigue (chromatic pupillometry studies) How colors map to semantic meaning across cultures (color semantics research) What syntax elements should be highlighted (empirical programming research) Instead of adjusting colors arbitrarily in HSL space, I could derive them from scientific principles.
Foundation 1: Perceptual Color Spaces The Problem with RGB and HSL RGB and HSL are convenient for computers but terrible for human perception. In RGB, the distance between #FF0000 (red) and #FF0011 (slightly different red) has no relationship to how different they appear to our eyes. HSL is better but still suffers from perceptual non-uniformity.
Enter Oklab Oklab [1] is a perceptually uniform color space designed by Björn Ottosson. In Oklab:
Euclidean distance corresponds to perceived color difference Lightness (L) separates from chroma Hue manipulation is more intuitive The transformation from Oklab to RGB involves four steps:
Step 1: Oklab → LMS (cone response)
[lms]=[10.39630.21581−0.1056−0.06391−0.0895−1.2915][Lab] \\begin{bmatrix} l \\\\ m \\\\ s \\end{bmatrix} = \\begin{bmatrix} 1 &amp; 0.3963 &amp; 0.2158 \\\\ 1 &amp; -0.1056 &amp; -0.0639 \\\\ 1 &amp; -0.0895 &amp; -1.2915 \\end{bmatrix} \\begin{bmatrix} L \\\\ a \\\\ b \\end{bmatrix} ​lms​​=​111​0.3963−0.1056−0.0895​0.2158−0.0639−1.2915​​​Lab​​Step 2: Inverse cube root
LMSlinear=[l3,m3,s3]T \\text{LMS}_{\\text{linear}} = [l^3, m^3, s^3]^T LMSlinear​=[l3,m3,s3]TStep 3: LMS → Linear RGB
[RGB]=[4.0767−3.30770.2310−1.26842.6098−0.3413−0.0042−0.70341.7076][l3m3s3] \\begin{bmatrix} R \\\\ G \\\\ B \\end{bmatrix} = \\begin{bmatrix} 4.0767 &amp; -3.3077 &amp; 0.2310 \\\\ -1.2684 &amp; 2.6098 &amp; -0.3413 \\\\ -0.0042 &amp; -0.7034 &amp; 1.7076 \\end{bmatrix} \\begin{bmatrix} l^3 \\\\ m^3 \\\\ s^3 \\end{bmatrix} ​RGB​​=​4.0767−1.2684−0.0042​−3.30772.6098−0.7034​0.2310−0.34131.7076​​​l3m3s3​​Step 4: Gamma correction (sRGB)
CsRGB={12.92×Clinearif Clinear≤0.00313081.055×Clinear1/2.4−0.055otherwise C_{\\text{sRGB}} = \\begin{cases} 12.92 \\times C_{\\text{linear}} &amp; \\text{if } C_{\\text{linear}} \\leq 0.0031308 \\\\ 1.055 \\times C_{\\text{linear}}^{1/2.4} - 0.055 &amp; \\text{otherwise} \\end{cases} CsRGB​={12.92×Clinear​1.055×Clinear1/2.4​−0.055​if Clinear​≤0.0031308otherwise​Implementation in Lua local function oklab_to_linear_rgb(L, a, b) -- Step 1: Oklab to LMS local l = L + 0.3963377774 * a + 0.2158037573 * b local m = L - 0.1055613458 * a - 0.0638541728 * b local s = L - 0.0894841775 * a - 1.2914855480 * b -- Step 2: Inverse cube root local l3, m3, s3 = l * l * l, m * m * m, s * s * s -- Step 3: LMS to linear RGB local r = 4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3 local g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3 local b_out = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3 return r, g, b_out end local function linear_to_srgb_component(c) -- Step 4: Gamma correction if c &lt;= 0.0031308 then return c * 12.92 else return 1.055 * (c ^ (1 / 2.4)) - 0.055 end end local function oklab_to_srgb(L, a, b) local r, g, b_comp = oklab_to_linear_rgb(L, a, b) r = linear_to_srgb_component(r) g = linear_to_srgb_component(g) b_comp = linear_to_srgb_component(b_comp) -- Clamp and convert to 8-bit r = math.floor(math.max(0, math.min(1, r)) * 255 + 0.5) g = math.floor(math.max(0, math.min(1, g)) * 255 + 0.5) b_comp = math.floor(math.max(0, math.min(1, b_comp)) * 255 + 0.5) return string.format(&#39;#%02x%02x%02x&#39;, r, g, b_comp) end Now I can specify colors as perceptual properties rather than hex codes:
-- Instead of: local orange = &#34;#c5895b&#34; -- I write: local orange = oklab_to_srgb(0.68, 0.055, 0.065) The formula is the color. No more arbitrary hex values.
Foundation 2: What to Highlight - Empirical Research Before deciding how to color code elements, I needed to understand which elements should be highlighted at all.
Hannebauer et al. (2018): The Surprising Truth About Syntax Highlighting A study with 390 programming novices [7] found something surprising:
&ldquo;Syntax highlighting has no significant effect on code comprehension or correctness&rdquo;
But the study revealed a crucial insight: highlighting does help when it emphasizes structural elements rather than coloring everything equally. The key principle:
Highlight structure, minimize noise.
Tonsky (2025): The Neutral Variables Principle Ivan Tonsky&rsquo;s analysis revealed why most themes feel noisy:
&ldquo;Your code is mostly references to variables and method invocation. If we highlight those, we&rsquo;ll have to highlight more than 75% of your code.&rdquo;
His recommendation: Keep variables and operators neutral (same color as regular text). Only highlight structural elements.
From Research to Design Decisions These findings led to my core highlighting strategy:
Highlight (bright colors):
Control flow keywords (if, for, while, return) Function definitions Type declarations Keep neutral (regular text color):
Variable names Operators Function parameters Dim (lower luminance):
Comments Delimiters This creates a visual hierarchy where code structure &ldquo;pops&rdquo; while the majority of text remains calm.
Foundation 3: Contrast Sensitivity Function (CSF) The human visual system doesn&rsquo;t respond uniformly to all contrasts. Barten&rsquo;s CSF model [2] reveals that we are 5-10× more sensitive to luminance contrast than chromatic contrast.
Key Insight: Luminance Hierarchy Matters More Than Hue This was the game-changer. Instead of asking &ldquo;should keywords be orange or yellow?&rdquo;, I should ask &ldquo;should keywords be brighter than data?&rdquo;
Deriving the Three-Layer Luminance Hierarchy I needed to design a luminance hierarchy that satisfies:
CSF comfort threshold: ΔL≥0.02\\Delta L \\geq 0.02ΔL≥0.02 for comfortable discrimination WCAG accessibility: Adequate contrast ratios with background Perceptual distinctness: Each layer feels clearly different Starting constraints:
Background: Lbg=0.24L_{\\text{bg}} = 0.24Lbg​=0.24 (dark theme, reduces eye strain) Foreground: Lfg=0.74L_{\\text{fg}} = 0.74Lfg​=0.74 (7.0:1 contrast, WCAG AAA)
Layer assignment based on Hannebauer (2018):
Layer 1 (highest): Structure (keywords, functions, types) - most important for comprehension Layer 2 (middle): Errors - need prominence without overwhelming Layer 3 (lowest): Data (strings, numbers) - secondary importance Calculating optimal luminance values:
The total usable luminance range is: Lfg−Lbg=0.74−0.24=0.50L_{\\text{fg}} - L_{\\text{bg}} = 0.74 - 0.24 = 0.50Lfg​−Lbg​=0.74−0.24=0.50
For syntax colors, I reserved the upper portion of this range to maintain sufficient contrast with background. Working backwards from foreground:
Lreserve=0.06 (headroom from foreground)Lmax_syntax=0.74−0.06=0.68 \\begin{aligned} L_{\\text{reserve}} &amp;= 0.06 \\text{ (headroom from foreground)} \\\\ L_{\\text{max\\_syntax}} &amp;= 0.74 - 0.06 = 0.68 \\end{aligned} Lreserve​Lmax_syntax​​=0.06 (headroom from foreground)=0.74−0.06=0.68​Now applying the CSF minimum threshold ΔL=0.02\\Delta L = 0.02ΔL=0.02:
Layer 1 (Structure):L1=0.68Layer 2 (Diagnostics):L2=L1−0.02=0.66Layer 3 (Data):L3=L2−0.02=0.64 \\begin{aligned} \\text{Layer 1 (Structure):} &amp;\\quad L_1 = 0.68 \\\\ \\text{Layer 2 (Diagnostics):} &amp;\\quad L_2 = L_1 - 0.02 = 0.66 \\\\ \\text{Layer 3 (Data):} &amp;\\quad L_3 = L_2 - 0.02 = 0.64 \\end{aligned} Layer 1 (Structure):Layer 2 (Diagnostics):Layer 3 (Data):​L1​=0.68L2​=L1​−0.02=0.66L3​=L2​−0.02=0.64​Verification against WCAG:
Using the contrast ratio formula CR=L1+0.05L2+0.05\\text{CR} = \\frac{L_1 + 0.05}{L_2 + 0.05}CR=L2​+0.05L1​+0.05​:
CR(L1,Lbg)=0.68+0.050.24+0.05=5.52:1(AA)CR(L2,Lbg)=0.66+0.050.24+0.05=5.03:1(AA)CR(L3,Lbg)=0.64+0.050.24+0.05=4.76:1(AA) \\begin{aligned} \\text{CR}(L_1, L_{\\text{bg}}) &amp;= \\frac{0.68 + 0.05}{0.24 + 0.05} = 5.52:1 \\quad \\text{(AA)} \\\\ \\text{CR}(L_2, L_{\\text{bg}}) &amp;= \\frac{0.66 + 0.05}{0.24 + 0.05} = 5.03:1 \\quad \\text{(AA)} \\\\ \\text{CR}(L_3, L_{\\text{bg}}) &amp;= \\frac{0.64 + 0.05}{0.24 + 0.05} = 4.76:1 \\quad \\text{(AA)} \\end{aligned} CR(L1​,Lbg​)CR(L2​,Lbg​)CR(L3​,Lbg​)​=0.24+0.050.68+0.05​=5.52:1(AA)=0.24+0.050.66+0.05​=5.03:1(AA)=0.24+0.050.64+0.05​=4.76:1(AA)​All three layers meet WCAG AA standards while maintaining ΔL=0.02\\Delta L = 0.02ΔL=0.02 separation.
Why this matters: In my old themes, I had errors (L=0.64L=0.64L=0.64) at the same brightness as strings. Errors weren&rsquo;t visually salient! Now errors are a distinct layer (L=0.66L=0.66L=0.66), immediately noticeable but not overwhelming.
Perceptual validation:
The 3-layer system creates three distinct &ldquo;brightness tiers&rdquo;:
Tier 1 (L=0.68L=0.68L=0.68): Code structure stands out, guides the eye Tier 2 (L=0.66L=0.66L=0.66): Errors pop without dominating Tier 3 (L=0.64L=0.64L=0.64): Data recedes appropriately This matches the importance hierarchy from Hannebauer&rsquo;s research: structure &gt; errors &gt; data.
Summary: The CSF-Optimized Luminance Hierarchy Layer Luminance Elements Rationale 1 L=0.68L=0.68L=0.68 Keywords, Functions, Types Highest importance for comprehension 2 L=0.66L=0.66L=0.66 Errors, Diagnostics Need prominence, not dominance 3 L=0.64L=0.64L=0.64 Strings, Numbers, Constants Secondary to structure - L=0.24L=0.24L=0.24 Background Low strain for long sessions - L=0.74L=0.74L=0.74 Foreground text 7.0:1 contrast (AAA) Key properties:
ΔL=0.02\\Delta L = 0.02ΔL=0.02 between layers (CSF comfortable threshold) All layers meet WCAG AA (contrast ≥4.5:1\\geq 4.5:1≥4.5:1) Total range: 0.64-0.68 (focused, not excessive) Foundation 4: CIECAM02 Color Appearance Model CIECAM02 [3] helps us understand how colors appear under different viewing conditions. The simplified chroma calculation is:
C≈100×s×J C \\approx 100 \\times s \\times \\sqrt{J} C≈100×s×J​where sss is saturation and JJJ is lightness (0-100 scale).
For comfortable long-term viewing, chroma should be in the range [30, 100]. This constrains our saturation:
s=C100×J s = \\frac{C}{100 \\times \\sqrt{J}} s=100×J​C​For L≈0.65L \\approx 0.65L≈0.65 (corresponding to J≈65J \\approx 65J≈65):
srecommended=65100×65≈0.081 s_{\\text{recommended}} = \\frac{65}{100 \\times \\sqrt{65}} \\approx 0.081 srecommended​=100×65​65​≈0.081This gives us the target saturation range: s∈[0.06,0.12]s \\in [0.06, 0.12]s∈[0.06,0.12].
Hue Discrimination CIECAM02 also tells us that for low-saturation colors, we need a minimum hue separation:
Δh≥20° to 25° \\Delta h \\geq 20° \\text{ to } 25° Δh≥20° to 25°I verified all adjacent hues meet this:
Red (27°) → Orange (50°): Δh = 23° ✓ Orange (50°) → Yellow (76°): Δh = 26° ✓ Yellow (76°) → Green (130°): Δh = 54° ✓ Green (130°) → Cyan (190°): Δh = 60° ✓ Cyan (190°) → Blue (252°): Δh = 62° ✓ Blue (252°) → Violet (321°): Δh = 69° ✓ Foundation 5: Color Fatigue Research A chromatic pupillometry study [4] found that different wavelengths cause different levels of visual fatigue:
Red (long wavelength): Highest fatigue (strongest pupil constriction) Yellow: Lowest fatigue Blue/Green: Intermediate The study recommends:
syellow/green&lt;0.10sred&lt;0.09saverage≈0.08 (for 8+ hour sessions) \\begin{aligned} s_{\\text{yellow/green}} &amp;&lt; 0.10 \\\\ s_{\\text{red}} &amp;&lt; 0.09 \\\\ s_{\\text{average}} &amp;\\approx 0.08 \\text{ (for 8+ hour sessions)} \\end{aligned} syellow/green​sred​saverage​​&lt;0.10&lt;0.09≈0.08 (for 8+ hour sessions)​Saturation Calculation In Oklab, saturation is:
s=a2+b2 s = \\sqrt{a^2 + b^2} s=a2+b2​For our colors:
-- Orange: s = √(0.055² + 0.065²) ≈ 0.085 ✓ colors.orange = oklab_to_srgb(0.68, 0.055, 0.065) -- Red: s = √(0.08² + 0.04²) ≈ 0.089 ✓ (just under 0.09 limit) colors.red = oklab_to_srgb(0.66, 0.08, 0.04) -- Yellow: s = √(0.02² + 0.08²) ≈ 0.082 ✓ colors.yellow = oklab_to_srgb(0.68, 0.02, 0.08) All saturations are in the low-fatigue zone.
Foundation 6: Color Semantics Karen Schloss&rsquo;s research [5] on color semantics reveals universal color-concept associations:
Red → Danger/Error (cross-cultural) Orange → Action/Warning (warm = activity) Yellow → Important/Attention (high visibility) Green → Success/Content (natural growth) Blue → Logic/Stability (cool = thinking) Cyan → Meta/Frozen (technical concepts) Deriving the AST Token → Color Mapping Here&rsquo;s how I mapped semantic concepts to code elements using color theory:
Step 1: Identify code semantic categories
From TreeSitter and LSP semantic tokens, code elements fall into these categories:
Control/Flow - Elements that change execution path Behavior - Functions and actions Structure - Type definitions and declarations Data - Literal values (strings, numbers) Meta - Compile-time constructs (macros, imports) Errors - Diagnostic information Step 2: Map to universal color semantics (Schloss 2023)
Code Category Semantic Property Color Association Chosen Color Control/Flow Action, Dynamic Warm colors (orange/red) Orange Behavior Logic, Stability Cool colors (blue) Blue Structure Important, Define High visibility (yellow) Yellow Data (strings) Content, Natural Growth (green) Green Data (numbers) Abstract Neutral (violet) Violet Meta Frozen, Technical Cold (cyan) Cyan Errors Danger Universal danger (red) Red Step 3: Apply luminance hierarchy
Not all categories are equally important. Based on CSF theory and Hannebauer&rsquo;s research:
Priority 1 (L=0.68L=0.68L=0.68): Structure elements guide understanding
Keywords (control flow) Functions (behavior) Types (declarations) Priority 2 (L=0.66L=0.66L=0.66): Errors need attention but shouldn&rsquo;t dominate
Diagnostic errors Priority 3 (L=0.64L=0.64L=0.64): Data is secondary to structure
Strings, numbers, constants Step 4: Calculate precise Oklab coordinates
For each color, I needed to satisfy:
Correct hue (from color semantics) Correct luminance (from CSF hierarchy) Safe saturation (from fatigue research) Sufficient hue separation (from CIECAM02) Example for Orange (keywords):
Target hue: h≈50°h \\approx 50°h≈50° (action/warm) Target luminance: L=0.68L = 0.68L=0.68 (high priority) Target saturation: s≈0.085s \\approx 0.085s≈0.085 (below 0.10 threshold) Converting hue to Oklab a,ba, ba,b coordinates:
a=s×cos⁡(h×π/180)b=s×sin⁡(h×π/180) \\begin{aligned} a &amp;= s \\times \\cos(h \\times \\pi / 180) \\\\ b &amp;= s \\times \\sin(h \\times \\pi / 180) \\end{aligned} ab​=s×cos(h×π/180)=s×sin(h×π/180)​For h=50°,s=0.085h = 50°, s = 0.085h=50°,s=0.085:
a=0.085×cos⁡(50°)≈0.055b=0.085×sin⁡(50°)≈0.065 \\begin{aligned} a &amp;= 0.085 \\times \\cos(50°) \\approx 0.055 \\\\ b &amp;= 0.085 \\times \\sin(50°) \\approx 0.065 \\end{aligned} ab​=0.085×cos(50°)≈0.055=0.085×sin(50°)≈0.065​Therefore: colors.orange = oklab_to_srgb(0.68, 0.055, 0.065)
I repeated this process for all seven colors, ensuring:
✓ Hue separation ≥20°\\geq 20°≥20° ✓ Saturation &lt;0.10&lt; 0.10&lt;0.10 (&lt;0.09&lt; 0.09&lt;0.09 for red) ✓ Luminance matches priority level ✓ Semantic alignment with code elements Complete Implementation Here&rsquo;s the final color palette definition:
local colors = {} -- Background (neutral, minimal chroma) colors.bg = oklab_to_srgb(0.24, 0.001, 0.006) colors.fg = oklab_to_srgb(0.74, 0.0, 0.008) -- Layer 1: Core Structure (L=0.68) colors.orange = oklab_to_srgb(0.68, 0.055, 0.065) -- Keywords colors.blue = oklab_to_srgb(0.68, -0.02, -0.06) -- Functions colors.yellow = oklab_to_srgb(0.68, 0.02, 0.08) -- Types -- Layer 2: Diagnostics (L=0.66) colors.red = oklab_to_srgb(0.66, 0.08, 0.04) -- Errors -- Layer 3: Data (L=0.64) colors.green = oklab_to_srgb(0.64, -0.05, 0.06) -- Strings colors.cyan = oklab_to_srgb(0.64, -0.055, -0.01) -- Constants colors.violet = oklab_to_srgb(0.64, 0.05, -0.04) -- Numbers return colors And the highlight group mappings that follow the research:
-- HIGH PRIORITY: Structure (bright, L=0.68) vim.api.nvim_set_hl(0, &#39;Keyword&#39;, { fg = colors.orange }) -- Control flow vim.api.nvim_set_hl(0, &#39;Function&#39;, { fg = colors.blue }) -- Behavior vim.api.nvim_set_hl(0, &#39;Type&#39;, { fg = colors.yellow }) -- Definitions -- LOW PRIORITY: Data (dimmer, L=0.64) vim.api.nvim_set_hl(0, &#39;String&#39;, { fg = colors.green }) vim.api.nvim_set_hl(0, &#39;Constant&#39;, { fg = colors.cyan }) vim.api.nvim_set_hl(0, &#39;Number&#39;, { fg = colors.violet }) -- NEUTRAL: Variables and operators (same as foreground) vim.api.nvim_set_hl(0, &#39;Identifier&#39;, { fg = colors.fg }) vim.api.nvim_set_hl(0, &#39;Operator&#39;, { fg = colors.fg }) Every value is derived from formulas, not arbitrary hex codes. Every mapping decision is backed by research.
Results I named it Retina a scientifically optimized colorscheme for human vision.
C code showing the luminance hierarchy in action. Keywords (orange, L=0.68L=0.68L=0.68) pop more than strings (green, L=0.64L=0.64L=0.64). Errors (red, L=0.66L=0.66L=0.66) are immediately visible.
After using this theme for 2 months, the difference is remarkable:
No more fatigue cycles: I can code for 10+ hours without eye strain Errors are immediately obvious: The L=0.66L=0.66L=0.66 layer works perfectly Structure is clear: Keywords/functions/types at L=0.68L=0.68L=0.68 guide my eyes to the code&rsquo;s skeleton Variables don&rsquo;t distract: Neutral colors reduce visual noise by ~75% Individual Differences: A Note of Caution It&rsquo;s crucial to understand that vision is deeply personal. This theme was optimized for:
My personal contrast sensitivity My typical viewing distance (~60cm) My display (MacBook Pro, ~400 nits) My ambient lighting (soft overhead lighting, ~300 lux) Your mileage may vary. Factors that affect color perception:
Age: Older adults need higher contrast [6] Display technology: OLED vs LCD affects color appearance Ambient light: Outdoor vs indoor viewing Individual differences: Color deficiency affects ~8% of males How to Adapt This for Yourself The beauty of the formula-based approach is that you can adjust the parameters rather than tweaking hex codes:
-- Want more contrast? Increase background-structure ΔL: colors.orange = oklab_to_srgb(0.70, 0.055, 0.065) -- was 0.68 -- Want lower saturation? Scale the a,b values: colors.orange = oklab_to_srgb(0.68, 0.044, 0.052) -- was (0.055, 0.065) -- Want warmer tones? Shift hue by adjusting a,b ratio: colors.orange = oklab_to_srgb(0.68, 0.050, 0.070) -- more yellow The formulas remain the foundation; you adjust coefficients rather than guessing hex values.
Summary and Takeaways What started as frustration with arbitrary theme tweaking led to a systematic, science-based approach:
Use perceptually uniform color spaces (Oklab) for predictable color manipulation Prioritize luminance hierarchy (CSF Theory) over hue differences Control saturation carefully (Color Fatigue research) for long-term comfort Respect perceptual thresholds (CIECAM02) for hue discrimination Align with semantic expectations (Color Semantics) for intuitive understanding Highlight structure, not noise (Hannebauer, Tonsky) for clarity I hope this approach helps others escape the arbitrary theme-tweaking trap. The science exists—we might as well use it.
References [1] Ottosson, B. (2020). A perceptual color space for image processing. https://bottosson.github.io/posts/oklab/
[2] Barten, P. G. J. (1999). Contrast sensitivity of the human eye and its effects on image quality. SPIE Press.
[3] Fairchild, M. D. (2013). Color appearance models (3rd ed.). John Wiley &amp; Sons.
[4] Cao, T., Zhang, M., Jiang, Y., Lu, C., &amp; Xu, Y. (2024). Effects of exposure to different light wavelengths on human eye fatigue. PMC, 11175232. https://www.ncbi.nlm.nih.gov/pmc/articles/PMC11175232/
[5] Schloss, K. B., &amp; Palmer, S. E. (2024). Color semantics for visual communication. Annual Review of Vision Science, 10, 1-25.
[6] Owsley, C. (2016). Vision and aging. Annual Review of Vision Science, 2, 255-271.
[7] Hannebauer, C., Hesenius, M., &amp; Gruhn, V. (2018). Does syntax highlighting help programming novices? Empirical Software Engineering, 23(5), 2795-2828.
Additional references:
IEC 61966-2-1:1999. Multimedia systems and equipment - Colour measurement and management - Part 2-1: Default RGB colour space - sRGB.
Tonsky, I. (2025). Syntax highlighting is a waste of time. https://tonsky.me/blog/syntax-highlighting/
The complete theme is available at here. Contributions and adaptations welcome.
`,url:"https://www.functor.me/posts/colorscheme/"},"https://www.functor.me/tags/vision-research/":{title:"Vision-Research",tags:[],content:"",url:"https://www.functor.me/tags/vision-research/"},"https://www.functor.me/categories/":{title:"Categories",tags:[],content:"",url:"https://www.functor.me/categories/"}}</script></footer></body></html>