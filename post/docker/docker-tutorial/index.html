<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Docker Tutorial - glepnir blog</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Docker Tutorial"><meta property="og:description" content="言简意赅的docker教程.可以迅速的熟悉和学会docker的各种操作."><meta property="og:type" content="article"><meta property="og:url" content="/post/docker/docker-tutorial/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-09-06T00:00:00+00:00"><meta property="article:modified_time" content="2020-09-06T00:00:00+00:00"><meta itemprop=name content="Docker Tutorial"><meta itemprop=description content="言简意赅的docker教程.可以迅速的熟悉和学会docker的各种操作."><meta itemprop=datePublished content="2020-09-06T00:00:00+00:00"><meta itemprop=dateModified content="2020-09-06T00:00:00+00:00"><meta itemprop=wordCount content="1238"><meta itemprop=keywords content="docker,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker Tutorial"><meta name=twitter:description content="言简意赅的docker教程.可以迅速的熟悉和学会docker的各种操作."><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><ul><li><a href=#镜像加速>镜像加速</a></li><li><a href=#启动docker>启动docker</a></li><li><a href=#docker的仓库>Docker的仓库</a></li><li><a href=#镜像的操作>镜像的操作</a></li><li><a href=#容器操作>容器操作</a></li><li><a href=#镜像>镜像</a></li><li><a href=#镜像提交>镜像提交</a></li><li><a href=#docker-registry-私服>Docker Registry 私服</a></li><li><a href=#数据卷>数据卷</a></li><li><a href=#dockerfile自定义镜像>Dockerfile自定义镜像</a></li><li><a href=#dockercompose>DockerCompose</a></li><li><a href=#dockercompose-管理>DockerCompose 管理</a></li><li><a href=#dockercompose-命令>DockerCompose 命令</a></li><li><a href=#dockercompos配合dockerfile一起使用>DockerCompos配合Dockerfile一起使用</a></li></ul></li></ul></nav></div></div></div><div class="container container--outer"><header class=header><div class="container header__container"><div class="logo logo--mixed"><a class=logo__link href=/ title="glepnir's blog" rel=home><div class="logo__item logo__imagebox"><img class=logo__img src=/images/avatar.svg></div><div class="logo__item logo__text"><div class=logo__title>glepnir's blog</div><div class=logo__tagline>A vimer work at neovim team</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>home</span></a></li><li class=menu__item><a class=menu__link href=/post/><span class=menu__text>Archives</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>categories</span></a></li><li class=menu__item><a class=menu__link href=/tags/><span class=menu__text>tags</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>about</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Docker Tutorial</h1><div class="post__meta meta"><div class="meta__item-author meta__item"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentcolor" class="bi bi-bar-chart-fill" viewBox="0 0 16 16"><path d="M1 11a1 1 0 011-1h2a1 1 0 011 1v3a1 1 0 01-1 1H2a1 1 0 01-1-1v-3zm5-4a1 1 0 011-1h2a1 1 0 011 1v7a1 1 0 01-1 1H7a1 1 0 01-1-1V7zm5-5a1 1 0 011-1h2a1 1 0 011 1v12a1 1 0 01-1 1h-2a1 1 0 01-1-1V2z"/></svg><span class=meta__text>1238</span></div><div class="meta__item-author meta__item"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentcolor" class="bi bi-hourglass-split" viewBox="0 0 16 16"><path d="M2.5 15a.5.5.0 110-1h1v-1a4.5 4.5.0 012.557-4.06c.29-.139.443-.377.443-.59v-.7c0-.213-.154-.451-.443-.59A4.5 4.5.0 013.5 3V2h-1a.5.5.0 010-1h11a.5.5.0 010 1h-1v1A4.5 4.5.0 019.943 7.06c-.29.139-.443.377-.443.59v.7c0 .213.154.451.443.59A4.5 4.5.0 0112.5 13v1h1a.5.5.0 010 1h-11zm2-13v1c0 .537.12 1.045.337 1.5h6.326c.216-.455.337-.963.337-1.5V2h-7zm3 6.35c0 .701-.478 1.236-1.011 1.492A3.5 3.5.0 004.5 13s.866-1.299 3-1.48V8.35zm1 0v3.17c2.134.181 3 1.48 3 1.48A3.5 3.5.0 009.511 9.842C8.978 9.586 8.5 9.052 8.5 8.351z"/></svg><span class=meta__text>6 minutes</span></div><div class="meta__item-datetime meta__item"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentcolor" class="bi bi-alarm" viewBox="0 0 16 16"><path d="M8.5 5.5a.5.5.0 00-1 0v3.362l-1.429 2.38a.5.5.0 10.858.515l1.5-2.5A.5.5.0 008.5 9V5.5z"/><path d="M6.5.0a.5.5.0 000 1H7v1.07A7.001 7.001.0 003.727 14.544l-.602.602a.5.5.0 00.707.708l.746-.746A6.97 6.97.0 008 16a6.97 6.97.0 003.422-.892l.746.746a.5.5.0 00.707-.708l-.601-.602A7.001 7.001.0 009 2.07V1h.5a.5.5.0 000-1h-3zm1.038 3.018a6.093 6.093.0 01.924.0 6 6 0 11-.924.0zM0 3.5c0 .753.333 1.429.86 1.887A8.035 8.035.0 014.387 1.86 2.5 2.5.0 000 3.5zM13.5 1c-.753.0-1.429.333-1.887.86a8.035 8.035.0 013.527 3.527A2.5 2.5.0 0013.5 1z"/></svg><time class=meta__text datetime=2020-09-06T00:00:00Z>2020-09-06</time></div><div class="meta__item-categories meta__item"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentcolor" class="bi bi-folder-fill" viewBox="0 0 16 16"><path d="M9.828 3h3.982a2 2 0 011.992 2.181l-.637 7A2 2 0 0113.174 14H2.825A2 2 0 01.834 12.181l-.637-7a1.99 1.99.0 01.342-1.31L.5 3a2 2 0 012-2h3.672a2 2 0 011.414.586l.828.828A2 2 0 009.828 3zm-8.322.12C1.72 3.042 1.95 3 2.19 3h5.396l-.707-.707A1 1 0 006.172 2H2.5a1 1 0 00-1 .981l.006.139z"/></svg><span class=meta__text><a class=meta__link href=/categories/docker/ rel=category>Docker</a></span></div></div></header><div class="content post__content clearfix"><p>言简意赅的docker教程.可以迅速的熟悉和学会docker的各种操作.</p><p>在linux和mac上安装docker的方式如下:</p><ul><li>CentOS</li></ul><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>yum <span style=color:#719e07>-</span>y install yum<span style=color:#719e07>-</span>utils device<span style=color:#719e07>-</span>mapper<span style=color:#719e07>-</span>persistent<span style=color:#719e07>-</span>data lvm2
</span></span><span style=display:flex><span>yum makecache fast
</span></span><span style=display:flex><span>yum <span style=color:#719e07>-</span>y install docker<span style=color:#719e07>-</span>ce
</span></span></code></pre></div><ul><li>Mac 安装 <code>Docker for Mac</code> 即可</li></ul><h3 id=镜像加速>镜像加速</h3><ul><li>CentOS</li></ul><p>默认下载Docker会去国外服务器下载，速度较慢，可以设置为阿里云镜像源，速度更快</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>yum<span style=color:#719e07>-</span>config<span style=color:#719e07>-</span>manager <span style=color:#719e07>--</span>add<span style=color:#719e07>-</span>repo http:<span style=color:#dc322f>//mi</span>rrors<span style=color:#719e07>.</span>aliyun<span style=color:#719e07>.</span>com<span style=color:#dc322f>/docker-ce/</span>linux<span style=color:#dc322f>/centos/</span>docker<span style=color:#719e07>-</span>ce<span style=color:#719e07>.</span>repo
</span></span></code></pre></div><ul><li>Mac</li></ul><p>登陆到阿里云找到镜像中心/镜像加速器会看到属于你自己的镜像加速器地址</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>https:<span style=color:#dc322f>//c</span>r<span style=color:#719e07>.</span>console<span style=color:#719e07>.</span>aliyun<span style=color:#719e07>.</span>com<span style=color:#dc322f>/cn-hangzhou/i</span>nstances<span style=color:#719e07>/</span>mirrors
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75># 一般长这个样子</span>
</span></span><span style=display:flex><span>https:<span style=color:#dc322f>//xxxxx</span><span style=color:#719e07>.</span>mirror<span style=color:#719e07>.</span>aliyuncs<span style=color:#719e07>.</span>com
</span></span></code></pre></div><p>将这个地址填写到docker的Preference的Docker Engine里 json的文件格式</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#268bd2>&#34;debug&#34;</span>: <span style=color:#cb4b16>true</span>,
</span></span><span style=display:flex><span>  <span style=color:#268bd2>&#34;experimental&#34;</span>: <span style=color:#cb4b16>false</span>,
</span></span><span style=display:flex><span>  <span style=color:#268bd2>&#34;registry-mirrors&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#2aa198>&#34;https://xxxx.mirror.aliyuncs.com&#34;</span>
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后重启Docker</p><ul><li>Proxy</li></ul><p>如果你使用一些proxy 软件例如ssr v2ray等,如果速度还可以的情况可以在终端使用代理的形式.</p><h3 id=启动docker>启动docker</h3><p>完成上面的操作已经简单的配置好了docker.启动docker.</p><p>安装成功后，需要手动启动，设置为开机启动，并测试一下 Docker</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#586e75>#启动docker服务</span>
</span></span><span style=display:flex><span>systemctl start docker
</span></span><span style=display:flex><span><span style=color:#586e75>#设置开机自动启动</span>
</span></span><span style=display:flex><span>systemctl enable docker
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>#Mac 直接省略上面打开docker客户端设置开机启动，当然你可以使用brew services的方式如果你使用brew cask安装的docker</span>
</span></span><span style=display:flex><span><span style=color:#586e75>#测试</span>
</span></span><span style=display:flex><span>docker run hello<span style=color:#719e07>-</span>world
</span></span></code></pre></div><h3 id=docker的仓库>Docker的仓库</h3><ol><li>Docker官方的中央仓库设置镜像加速后速度就不会很慢推荐使用</li></ol><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>https:<span style=color:#dc322f>//</span>hub<span style=color:#719e07>.</span>docker<span style=color:#719e07>.</span>com<span style=color:#719e07>/</span>
</span></span></code></pre></div><ol start=2><li>在公司内部会采用私服的方式拉取镜像（添加配置）一般都是用linux做服务器</li></ol><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#586e75>//需要创建 /etc/docker/daemon.json，并添加如下内容
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>{
</span></span><span style=display:flex><span>    <span style=color:#268bd2>&#34;registry-mirrors&#34;</span>:[<span style=color:#2aa198>&#34;https://registry.docker-cn.com&#34;</span>],
</span></span><span style=display:flex><span>    <span style=color:#268bd2>&#34;insecure-registries&#34;</span>:[<span style=color:#2aa198>&#34;ip:port&#34;</span>]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>添加后需要重启docker</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#586e75>#重启两个服务</span>
</span></span><span style=display:flex><span>systemctl daemon<span style=color:#719e07>-</span>reload
</span></span><span style=display:flex><span>systemctl restart docker
</span></span></code></pre></div><h3 id=镜像的操作>镜像的操作</h3><p>docke search 查找镜像
当安装和配置好docker
后在本地上是不存在任何镜像的,这时候就需要去镜像仓库拉取需要的镜像,在拉取之前可以通过查找的操作,来查看所需要的镜像是否在仓库之中.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker search redis
</span></span></code></pre></div><p>如果查找到了redis镜像的信息,它会输出一些关于该镜像的信息例如名称,描述,star,是否官方等等,如果没有那么仓库就不存在该镜像需要换一个仓库.</p><p><code>--limit</code> 参数可以进行输出镜像的结果数量限制.一般都是使用官方镜像.</p><p>docke pull 拉取镜像</p><p>从中央仓库拉取镜像到本地 一般不填 tag 会拉去最新的也就是 latest
docker pull 镜像名称[:tag]</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#586e75>#例如</span>
</span></span><span style=display:flex><span>docker pull mongo
</span></span></code></pre></div><p>查看本地镜像 docker images 还可以再后面加入一些参数 -q 只显示镜像id 默认是-a
列出所有镜像</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#586e75>#输出的格式如下</span>
</span></span><span style=display:flex><span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span style=display:flex><span>mongo               latest              <span style=color:#2aa198>409</span>c3f937574        <span style=color:#2aa198>5</span> days ago          <span style=color:#2aa198>493</span>MB
</span></span><span style=display:flex><span>hello<span style=color:#719e07>-</span>world         latest              bf756fb1ae65        <span style=color:#2aa198>7</span> months ago        <span style=color:#2aa198>13.3</span>kB
</span></span></code></pre></div><p>镜像ID就是sha256 的字符串. 下载带有tag的镜像例如redis 6系列版本的镜像</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker pull redis:6<span style=color:#2aa198>.0.8</span>
</span></span></code></pre></div><p>删除镜像 docker rmi (-f) 镜像ID rm 一般*nix的删除前缀 i就是image的i -f
就是强制删除.当镜像在容器中时则需要-f 强制删除</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#586e75>#例如删除mongo</span>
</span></span><span style=display:flex><span>docker rmi <span style=color:#2aa198>409</span>c3f937574
</span></span><span style=display:flex><span><span style=color:#586e75>#如果要删除多个镜像</span>
</span></span><span style=display:flex><span>docker rmi id1 id2
</span></span><span style=display:flex><span><span style=color:#586e75>#删除全部的容器</span>
</span></span><span style=display:flex><span>docker rmi <span style=color:#719e07>-</span>f <span style=color:#268bd2>$</span>(<span style=color:#268bd2>docker</span> images <span style=color:#719e07>-</span>qa)
</span></span></code></pre></div><p>查看docker 镜像容器数据卷的占用信息</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker <span style=color:#b58900>system</span> df
</span></span></code></pre></div><p>镜像的导入导出</p><p>如果因为网络原因可以通过硬盘的方式传输镜像，虽然不规范，但是有效，但是这种方式导出的镜像名称和版本都是null，需要手动修改</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#586e75>#将本地的镜像导出</span>
</span></span><span style=display:flex><span>docker save <span style=color:#719e07>-</span>o 导出的文件路径 镜像id
</span></span><span style=display:flex><span><span style=color:#586e75>#加载本地的镜像文件</span>
</span></span><span style=display:flex><span>docker load <span style=color:#719e07>-</span>i 镜像文件
</span></span><span style=display:flex><span><span style=color:#586e75>#修改镜像文件</span>
</span></span><span style=display:flex><span>docker tag 镜像id 新镜像名称:版本
</span></span></code></pre></div><p>例如打包mongo镜像(确保先创建你要导出的文件夹)</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker save <span style=color:#719e07>-</span>o <span style=color:#719e07>~</span><span style=color:#dc322f>/dockerimage/mo</span>ngo <span style=color:#2aa198>409</span>c3f937574
</span></span><span style=display:flex><span><span style=color:#586e75>#加载本地镜像</span>
</span></span><span style=display:flex><span>docker load <span style=color:#719e07>-</span>i <span style=color:#719e07>~</span><span style=color:#dc322f>/dockerimage/mo</span>ngo
</span></span><span style=display:flex><span><span style=color:#586e75>#output 加载镜像的layer</span>
</span></span><span style=display:flex><span>c5ff2d88f679: Loading layer  <span style=color:#2aa198>80.33</span>MB<span style=color:#719e07>/</span><span style=color:#2aa198>80.33</span>MB
</span></span><span style=display:flex><span><span style=color:#2aa198>8</span>a9da272b7d2: Loading layer  <span style=color:#2aa198>340.5</span>kB<span style=color:#719e07>/</span><span style=color:#2aa198>340.5</span>kB
</span></span><span style=display:flex><span><span style=color:#2aa198>1380</span>b7095b41: Loading layer  <span style=color:#2aa198>12.19</span>MB<span style=color:#719e07>/</span><span style=color:#2aa198>12.19</span>MB
</span></span><span style=display:flex><span>d1e9c181d71c: Loading layer  <span style=color:#2aa198>3.515</span>MB<span style=color:#719e07>/</span><span style=color:#2aa198>3.515</span>MB
</span></span><span style=display:flex><span><span style=color:#2aa198>4</span>dcad5cb53c6: Loading layer  <span style=color:#2aa198>2.048</span>kB<span style=color:#719e07>/</span><span style=color:#2aa198>2.048</span>kB
</span></span><span style=display:flex><span><span style=color:#2aa198>7e48</span>cf4fe2cc: Loading layer   <span style=color:#2aa198>5.12</span>kB<span style=color:#719e07>/</span><span style=color:#2aa198>5.12</span>kB
</span></span><span style=display:flex><span><span style=color:#2aa198>0e190450333</span>c: Loading layer  <span style=color:#2aa198>3.584</span>kB<span style=color:#719e07>/</span><span style=color:#2aa198>3.584</span>kB
</span></span><span style=display:flex><span>b7e89712287a: Loading layer  <span style=color:#2aa198>547.4</span>MB<span style=color:#719e07>/</span><span style=color:#2aa198>547.4</span>MB
</span></span><span style=display:flex><span><span style=color:#2aa198>2</span>d3d91132f03: Loading layer  <span style=color:#2aa198>17.41</span>kB<span style=color:#719e07>/</span><span style=color:#2aa198>17.41</span>kB
</span></span><span style=display:flex><span>Loaded image ID: sha256:a440572ac3c10fdc02c51d46a2dcbf3760d10faf3f6a2784054e6e1057f0d92a
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>#然后docker images 查看一下</span>
</span></span><span style=display:flex><span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span style=display:flex><span><span style=color:#dc322f>&lt;none&gt;</span>              <span style=color:#dc322f>&lt;none&gt;</span>              <span style=color:#2aa198>409</span>c3f937574        <span style=color:#2aa198>5</span> days ago          <span style=color:#2aa198>493</span>MB
</span></span><span style=display:flex><span>hello<span style=color:#719e07>-</span>world         latest              bf756fb1ae65        <span style=color:#2aa198>7</span> months ago        <span style=color:#2aa198>13.3</span>kB
</span></span></code></pre></div><p>这个 <code>none</code> 就是加载的已经打包到本地的mongo ID大小都是一样的. none 这个镜像叫做虚悬镜像(dangling
iamge)</p><p>修改这个虚悬镜像的name 和tag</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker tag ImageID mongo:latest
</span></span><span style=display:flex><span><span style=color:#586e75>#再用docker images查看一下 这样就顺眼了</span>
</span></span><span style=display:flex><span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span style=display:flex><span>mongo               latest              <span style=color:#2aa198>409</span>c3f937574        <span style=color:#2aa198>5</span> days ago          <span style=color:#2aa198>493</span>MB
</span></span><span style=display:flex><span>hello<span style=color:#719e07>-</span>world         latest              bf756fb1ae65        <span style=color:#2aa198>7</span> months ago        <span style=color:#2aa198>13.3</span>kB
</span></span></code></pre></div><h3 id=容器操作>容器操作</h3><p>运行容器需要定制具体镜像，如果镜像不存在，会直接下载</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker run 镜像的ID<span style=color:#719e07>|</span>镜像的名称[:tag]
</span></span></code></pre></div><p>常用的参数</p><ul><li><code>-d</code>(daemon):代表后台运行容器</li><li><code>-p</code>(port):宿主机端口:容器端口：为了映射当前Linux的端口和容器的端口</li><li><code>-P</code>随机端口</li><li><code>-i</code>(interactive): 交互启动</li><li><code>-t</code>(tty): 分配一个伪终端一般与 -i一起使用</li><li><code>--name</code>:容器名称:指定容器的名称</li></ul><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker run <span style=color:#719e07>-</span>d <span style=color:#719e07>-</span>p 宿主机端口:容器端口 <span style=color:#719e07>--</span>name 容器名称 镜像ID 或者 镜像名称[:tag]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>#例如启动mysql 之后会看到容器id的输出即为启动容器成功</span>
</span></span><span style=display:flex><span>docker run <span style=color:#719e07>-</span>d <span style=color:#719e07>-</span>p <span style=color:#2aa198>3309</span>:<span style=color:#2aa198>3306</span> <span style=color:#719e07>--</span>name mysql <span style=color:#2aa198>0</span>d
</span></span></code></pre></div><p>查看全部正在运行的容器信息</p><ul><li>-a 查看全部的容器，包括没有运行</li><li>-q 只查看容器的标识</li><li>-l 显示最近创建的容器</li><li>-n 显示最近n个创建的容器</li></ul><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker ps [<span style=color:#719e07>-</span>qa]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>#会有这样的输出 当前容器的id</span>
</span></span><span style=display:flex><span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
</span></span><span style=display:flex><span>d00f6136b0d7        bf                  <span style=color:#2aa198>&#34;/hello&#34;</span>            <span style=color:#2aa198>5</span> seconds ago       Exited (<span style=color:#2aa198>0</span>) <span style=color:#2aa198>4</span> seconds ago                       hopeful_poitras
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>#只显示最近创建的容器</span>
</span></span><span style=display:flex><span>docke ps <span style=color:#719e07>-</span>l
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>#只显示1个创建的容器</span>
</span></span><span style=display:flex><span>docker ps <span style=color:#719e07>-</span>n <span style=color:#2aa198>1</span>
</span></span></code></pre></div><p>退出容器</p><p>当以交互式的形式启动容器后 dock run -it ubuntu bash.
会进入到容器的bash中.那么如何退出当前的容器两种办法:</p><ul><li>输入exit 会停掉正在运行的容器</li><li>快捷键ctrl+p+q 退出.不会停掉容器</li></ul><p>查看容器日志，以查看容器运行的信息</p><ul><li>-f：可以滚动查看日志的最后几行</li></ul><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker logs <span style=color:#719e07>-</span>f 容器id
</span></span></code></pre></div><p>进入容器的内部进行操作，例如进入容器内部的shell(默认是bash)
exec是execute的简写执行的意思。记住单词也就记住了。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker <span style=color:#b58900>exec</span> <span style=color:#719e07>-</span>it 容器id bash
</span></span></code></pre></div><p>进入后可通过输入exit 退出回到当前的环境,并且不会停掉容器</p><p>重新连接容器 docker attach</p><p>当通过使用交互式启动容器时例如 docker run -it -d ubuntu bash
时,如上所述我们可以使用exit和快捷键退出容器.那么当我们是用快捷键退出容器后如何在进去呢.
可以使用</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker attach 容器id
</span></span><span style=display:flex><span><span style=color:#586e75>#注意这里如果继续使用exit 退出容器仍然会停掉容器</span>
</span></span></code></pre></div><p>查看容器内部运行的进程</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker top 容器id
</span></span></code></pre></div><p>打印容器信息</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker inspect 容器id
</span></span></code></pre></div><p>容器的启动，暂停，停止，删除等操作，后续会经常使用到</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#586e75>#暂停容器</span>
</span></span><span style=display:flex><span>docker pause 容器id
</span></span><span style=display:flex><span><span style=color:#586e75>#恢复容器</span>
</span></span><span style=display:flex><span>docker unpause 容器id
</span></span><span style=display:flex><span><span style=color:#586e75>#重新启动容器</span>
</span></span><span style=display:flex><span>docker restart 容器id
</span></span><span style=display:flex><span><span style=color:#586e75>#启动运行的容器</span>
</span></span><span style=display:flex><span>docker start 容器id
</span></span><span style=display:flex><span><span style=color:#586e75>#停止指定的容器</span>
</span></span><span style=display:flex><span>docker stop 容器id
</span></span><span style=display:flex><span><span style=color:#586e75>#停止全部容器</span>
</span></span><span style=display:flex><span>docker stop <span style=color:#268bd2>$</span>(<span style=color:#268bd2>docker</span> ps <span style=color:#719e07>-</span>qa)
</span></span><span style=display:flex><span><span style=color:#586e75>#删除指定容器</span>
</span></span><span style=display:flex><span>docker rm 容器id
</span></span><span style=display:flex><span><span style=color:#586e75>#删除全部容器 -f 就是force 强制删除可以删除正在运行的容器</span>
</span></span><span style=display:flex><span>docker rm (<span style=color:#719e07>-</span>f) <span style=color:#268bd2>$</span>(<span style=color:#268bd2>docker</span> ps <span style=color:#719e07>-</span>qa)
</span></span><span style=display:flex><span><span style=color:#586e75>#另一种方式使用管道的形式</span>
</span></span><span style=display:flex><span>docker ps <span style=color:#719e07>-</span>a <span style=color:#719e07>-</span><span style=color:#2aa198>q | </span>xargs docker rm
</span></span><span style=display:flex><span><span style=color:#586e75>#强制停止容器</span>
</span></span><span style=display:flex><span>docker <span style=color:#b58900>kill</span> 容器id
</span></span></code></pre></div><p>例如删除hello-world容器</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#586e75>#查看到ID</span>
</span></span><span style=display:flex><span>docker ps <span style=color:#719e07>-</span>a 
</span></span><span style=display:flex><span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
</span></span><span style=display:flex><span>d00f6136b0d7        bf                  <span style=color:#2aa198>&#34;/hello&#34;</span>            <span style=color:#2aa198>5</span> seconds ago       Exited (<span style=color:#2aa198>0</span>) <span style=color:#2aa198>4</span> seconds ago                       hopeful_poitras
</span></span><span style=display:flex><span><span style=color:#586e75>#停止容器</span>
</span></span><span style=display:flex><span>docker stop d00
</span></span><span style=display:flex><span><span style=color:#586e75>#删除容器</span>
</span></span><span style=display:flex><span>docker rm d00
</span></span><span style=display:flex><span><span style=color:#586e75>#查看一下</span>
</span></span><span style=display:flex><span>docker ps <span style=color:#719e07>-</span>a
</span></span><span style=display:flex><span><span style=color:#586e75>#hello-world 容器已经不存在了</span>
</span></span><span style=display:flex><span><span style=color:#586e75>#然后就可以删除掉hello-world镜像</span>
</span></span><span style=display:flex><span>docker rmi hello<span style=color:#719e07>-</span>wolrd的id即可
</span></span><span style=display:flex><span><span style=color:#586e75>#再用docker images查看一下</span>
</span></span><span style=display:flex><span><span style=color:#586e75>#没有了hello-world的镜像</span>
</span></span></code></pre></div><p>当然可以通过使用docker rm -f hello-world 强制删除不过在开发时候为了确保不出意外一般都是先停止在删除.</p><p>实例启动mysql容器</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#586e75>#例如docker运行mysql</span>
</span></span><span style=display:flex><span>➜ docker pull mysql
</span></span><span style=display:flex><span><span style=color:#586e75>#查看镜像</span>
</span></span><span style=display:flex><span>➜ docker images
</span></span><span style=display:flex><span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span style=display:flex><span>mysql               latest              <span style=color:#2aa198>0</span>d64f46acfd1        <span style=color:#2aa198>3</span> weeks ago         <span style=color:#2aa198>544</span>MB
</span></span><span style=display:flex><span><span style=color:#586e75>#后台运行容器 -e 加上初始化的root密码 否则mysql 会启动失败(可通过logs -f查看到日志)</span>
</span></span><span style=display:flex><span>➜ docker run <span style=color:#719e07>-</span>d <span style=color:#719e07>-</span>p <span style=color:#2aa198>3309</span>:<span style=color:#2aa198>3306</span> <span style=color:#719e07>-</span>e MYSQL_ROOT_PASSWORD<span style=color:#719e07>=</span><span style=color:#2aa198>123456</span>   <span style=color:#719e07>--</span>name mysql <span style=color:#2aa198>0</span>d
</span></span><span style=display:flex><span><span style=color:#586e75>#输出容器id 即为启动成功</span>
</span></span><span style=display:flex><span>d20bfc8e2eaf35773a911a8e5e3af8b1bce024a16e7687000d9ef476c4fc3f0e
</span></span><span style=display:flex><span><span style=color:#586e75># 查看当前的容器</span>
</span></span><span style=display:flex><span>➜ docker ps <span style=color:#719e07>-</span>a
</span></span><span style=display:flex><span>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES
</span></span><span style=display:flex><span>d20bfc8e2eaf        <span style=color:#2aa198>0</span>d                  <span style=color:#2aa198>&#34;docker-entrypoint.s…&#34;</span>   <span style=color:#2aa198>3</span> seconds ago       Up <span style=color:#2aa198>3</span> seconds        <span style=color:#2aa198>33060</span><span style=color:#dc322f>/tcp, 0.0.0.0:3309-&gt;3306/</span>tcp   mysql
</span></span><span style=display:flex><span><span style=color:#586e75># 进入容器的内部shell环境连接mysqlclient</span>
</span></span><span style=display:flex><span>root<span style=color:#268bd2>@d20bfc8e2eaf:</span><span style=color:#719e07>/</span><span style=color:#586e75># mysql -u root -p</span>
</span></span><span style=display:flex><span>Enter password:
</span></span><span style=display:flex><span>Welcome to the MySQL monitor<span style=color:#719e07>.</span>  Commands end with ; <span style=color:#719e07>or</span> <span style=color:#719e07>\</span>g<span style=color:#719e07>.</span>
</span></span><span style=display:flex><span>Your MySQL connection id is <span style=color:#2aa198>10</span>
</span></span><span style=display:flex><span>Server version: <span style=color:#2aa198>8.0.21</span> MySQL Community Server <span style=color:#719e07>-</span> GPL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Copyright (c) <span style=color:#2aa198>2000</span>, <span style=color:#2aa198>2020</span>, Oracle <span style=color:#719e07>and</span><span style=color:#719e07>/</span><span style=color:#719e07>or</span> its affiliates<span style=color:#719e07>.</span> All rights reserved<span style=color:#719e07>.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Oracle is a registered trademark of Oracle Corporation <span style=color:#719e07>and</span><span style=color:#719e07>/</span><span style=color:#719e07>or</span> its
</span></span><span style=display:flex><span>affiliates<span style=color:#719e07>.</span> Other names may be trademarks of their respective
</span></span><span style=display:flex><span>owners<span style=color:#719e07>.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Type <span style=color:#2aa198>&#39;help;&#39;</span> <span style=color:#719e07>or</span> <span style=color:#2aa198>&#39;\h&#39;</span> <span style=color:#719e07>for</span> help<span style=color:#719e07>.</span> Type <span style=color:#2aa198>&#39;\c&#39;</span> to clear the current input statement<span style=color:#719e07>.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mysql<span style=color:#719e07>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>#成功运行了mysql</span>
</span></span><span style=display:flex><span><span style=color:#586e75># 退出mysql</span>
</span></span><span style=display:flex><span>mysql<span style=color:#719e07>&gt;</span> <span style=color:#719e07>\</span><span style=color:#2aa198>q
</span></span></span><span style=display:flex><span><span style=color:#2aa198># 退出容器
</span></span></span><span style=display:flex><span><span style=color:#2aa198></span>root<span style=color:#268bd2>@d20bfc8e2eaf:</span><span style=color:#719e07>/</span><span style=color:#586e75># exit</span>
</span></span></code></pre></div><p>可以通过各种数据库的gui客户端进行连接当前的mysql容器,需要注意的是这个例子中使用主机的3309做为映射端口那么在使用客户端连接的时候切记修改默认的3306端口为3309
端口。当然你也可以使用主机的3306端口映射容器的3306端口在启动容器的时候.</p><p>在编程的时候连接数据库 例如go中使用docker的mysql</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#268bd2>ConnectSQL</span>(<span style=color:#2aa198>&#34;localhost&#34;</span>, <span style=color:#2aa198>&#34;3309&#34;</span>, <span style=color:#2aa198>&#34;root&#34;</span>, <span style=color:#2aa198>&#34;123456&#34;</span>, <span style=color:#2aa198>&#34;mysql&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// ConnectSQL ...
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>func</span> <span style=color:#268bd2>ConnectSQL</span>(host, port, uname, pass, dbname <span style=color:#dc322f>string</span>) {
</span></span><span style=display:flex><span>	dbSource <span style=color:#719e07>:=</span> fmt.<span style=color:#268bd2>Sprintf</span>(
</span></span><span style=display:flex><span>		<span style=color:#2aa198>&#34;root:%s@tcp(%s:%s)/%s?charset=utf8&#34;</span>,
</span></span><span style=display:flex><span>		pass,
</span></span><span style=display:flex><span>		host,
</span></span><span style=display:flex><span>		port,
</span></span><span style=display:flex><span>		dbname,
</span></span><span style=display:flex><span>	)
</span></span><span style=display:flex><span>	d, err <span style=color:#719e07>:=</span> sql.<span style=color:#268bd2>Open</span>(<span style=color:#2aa198>&#34;mysql&#34;</span>, dbSource)
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#b58900>panic</span>(err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	err = d.<span style=color:#268bd2>Ping</span>()
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#b58900>panic</span>(err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	fmt.<span style=color:#268bd2>Println</span>(<span style=color:#2aa198>&#34;Connection success&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>极大的改善了开发体验，你可以简单有快速的安装不同版本和不同类型的数据库。</p><p>容器拷贝文件到主机 docker cp 容器id:容器内路径 目标主机路径</p><p>首先启动一个Ubuntu容器,然后进入到这个ubuntu容器中</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#586e75>#启动ubuntu容器</span>
</span></span><span style=display:flex><span>docker run <span style=color:#719e07>-</span>it ubuntu bash
</span></span><span style=display:flex><span><span style=color:#586e75>#目前已经在ubuntu容器内了在任何目录创建一个文件</span>
</span></span><span style=display:flex><span>touch a<span style=color:#719e07>.</span>txt
</span></span><span style=display:flex><span><span style=color:#586e75>#使用重定向的方式写入一些字符串</span>
</span></span><span style=display:flex><span>echo <span style=color:#2aa198>&#39;from ubuntu&#39;</span> <span style=color:#719e07>&gt;</span> a<span style=color:#719e07>.</span>txt
</span></span><span style=display:flex><span><span style=color:#586e75>#使用cat命令查看是否写入成功</span>
</span></span><span style=display:flex><span>cat a<span style=color:#719e07>.</span>txt
</span></span><span style=display:flex><span><span style=color:#586e75>#正常情况会输出刚写入的字符串 from ubuntu</span>
</span></span><span style=display:flex><span><span style=color:#586e75>#使用ctrl+p+q退出这个容器 前面讲过快捷键不会停掉容器</span>
</span></span><span style=display:flex><span><span style=color:#586e75>#使用cp命令把刚才创建的a.txt文件拷贝到当前目录下</span>
</span></span><span style=display:flex><span>docker cp 容器id:<span style=color:#dc322f>/a.txt ./</span>
</span></span><span style=display:flex><span><span style=color:#586e75>#通过ls 命令查看存在a.txt文件已经拷贝成功了</span>
</span></span><span style=display:flex><span><span style=color:#586e75>#cat a.txt 会输出from ubuntu</span>
</span></span></code></pre></div><p>导出容器 docker export 容器id > 文件名.tar</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#586e75>#注意导出是不会停掉正在运行的容器的</span>
</span></span><span style=display:flex><span>docker export ubuntu容器id <span style=color:#719e07>&gt;</span> ubuntu<span style=color:#719e07>.</span>tar
</span></span><span style=display:flex><span><span style=color:#586e75>#ubuntu容器仍然在运行</span>
</span></span><span style=display:flex><span>docker  ps <span style=color:#719e07>-</span>a
</span></span></code></pre></div><p>导入容器镜像 cat 镜像.tar | docker import - 镜像用户/镜像名:镜像版本号</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#586e75>#首先强制删除刚才的ubuntu镜像</span>
</span></span><span style=display:flex><span>docker rm <span style=color:#719e07>-</span>f ubuntu容器id
</span></span><span style=display:flex><span><span style=color:#586e75>#查看确认已经没有了ubuntu容器</span>
</span></span><span style=display:flex><span>docker ps <span style=color:#719e07>-</span>a
</span></span><span style=display:flex><span><span style=color:#586e75>#导入刚才导出的ubuntu容器镜像 这里就可以随便写一些信息</span>
</span></span><span style=display:flex><span>cat ubuntu<span style=color:#719e07>.</span>tar <span style=color:#719e07>|</span> docker <span style=color:#b58900>import</span> <span style=color:#719e07>-</span>test<span style=color:#719e07>/</span>test:0<span style=color:#2aa198>.1.0</span>
</span></span><span style=display:flex><span><span style=color:#586e75>#导入完成后会看到sha256的id输出 使用</span>
</span></span><span style=display:flex><span>docker images
</span></span><span style=display:flex><span><span style=color:#586e75>#查看全部的镜像会看到刚导入的镜像</span>
</span></span></code></pre></div><h3 id=镜像>镜像</h3><p>是一种轻量级，可独立的独立软件包，它包含运行某个应用程序所需的所有内容，把应用程序和配置依赖打包成一个可交付的运行环境，这个打包好的运行环境就简称为镜像</p><p>分层镜像</p><p>当使用pull命令拉取一个新的镜像时经常看到是这样的输出</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker pull mongo
</span></span><span style=display:flex><span><span style=color:#586e75># output</span>
</span></span><span style=display:flex><span>latest: Pulling from library<span style=color:#719e07>/</span>mongo
</span></span><span style=display:flex><span>b65bcf19d144: Pulling fs layer
</span></span><span style=display:flex><span><span style=color:#2aa198>83449</span>d568304: Pulling fs layer
</span></span><span style=display:flex><span><span style=color:#2aa198>20</span>d982b8a1de: Waiting
</span></span><span style=display:flex><span><span style=color:#2aa198>40</span>b500d3ec7f: Waiting
</span></span></code></pre></div><p>在上面的输出中会看到许多的fs layer 文件层,一个镜像是由许多个文件构成的.底层的原理就是
Union fs(联合文件系统).</p><p>Union Fs (联合文件系统)
是一种分层,轻量级的高性能文件系统,它支持对文件系统的修改作为一次提交来一层层的叠加.同时可以将不同的目录挂载到通一个虚拟文件系统下.
Union文件系统是docker镜像的基础.镜像可以通过分层来继承.基于基础的镜像可以制作各种不同应用的镜像.</p><p>特性:
一次同时加载多个文件系统,但从外面看起来,只能看到一个文件系统,联合加载会把各层文件叠加起来,这样最终的文件系统会包含所有底层的文件和目录.</p><h4 id=docker镜像加载原理>Docker镜像加载原理</h4><p>docker的镜像实际上由一层一层的文件系统组成,这种层级的文件系统叫做UnionFs.</p><p>bootfs(boot file system)主要包含bootloader和kernel,
bootloader主要是加载kernel,linux刚启动的时候会加载bootfs文件系统,在docker镜像的最底层就是引导文件系统bootfs.这一层与典型的linux或者unix系统是一样的.
当boot加载完成之后整个内核就在内存中了,此时的内存使用权就由boot转交给了kernel,此时系统也会卸载bootfs</p><p>rootfs(root file system)在bootfs之上,包含的就是典型的linux或者unix系统中的/dev /proc /bin
/etc等标准目录和文件, rootfs就是各种不同操作系统的发行版例如ubuntu centos 等等.</p><h3 id=镜像提交>镜像提交</h3><p>docker commit -m=&ldquo;提交的信息&rdquo; -a=&ldquo;作者&rdquo; 容器id 要创建的镜像名:tag</p><p>之前创建的ubuntu容器使用的官方镜像.这种镜像一般只包含一个linux
kernel没有其他任何常用的一些外部程序例如vim等.
尝试安装一个vim然后提交打包这个ubuntu容器成为一个新的带有vim的ubuntu镜像.</p><p>ubuntu的包管理器使用的是apt-get。所以先尝试更新下包管理器</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#586e75>#更新</span>
</span></span><span style=display:flex><span>docker run <span style=color:#719e07>-</span>it ubuntu bash
</span></span><span style=display:flex><span>apt<span style=color:#719e07>-</span>get update
</span></span><span style=display:flex><span><span style=color:#586e75>#安装vim</span>
</span></span><span style=display:flex><span>apt<span style=color:#719e07>-</span>get <span style=color:#719e07>-</span>y install vim
</span></span><span style=display:flex><span><span style=color:#586e75>#安装完成后打开vim测试一下都正常的.提交这个镜像 用户名要与hub.docker上面一致</span>
</span></span><span style=display:flex><span>docker commit <span style=color:#719e07>-</span>m<span style=color:#719e07>=</span><span style=color:#2aa198>&#34;ubuntu with vim&#34;</span> <span style=color:#719e07>-</span>a<span style=color:#719e07>=</span><span style=color:#2aa198>&#34;glepnir&#34;</span> <span style=color:#2aa198>3730</span> glephunter<span style=color:#719e07>/</span>myubuntu:0<span style=color:#2aa198>.1.0</span>
</span></span><span style=display:flex><span><span style=color:#586e75>#提交镜像到hub.docker去</span>
</span></span><span style=display:flex><span>docker <span style=color:#b58900>push</span> glephunter<span style=color:#719e07>/</span>myubuntu:0<span style=color:#2aa198>.1.0</span>
</span></span></code></pre></div><h3 id=docker-registry-私服>Docker Registry 私服</h3><p>一般企业内部会因为私密性等原因创建自己的本地docker 镜像服务器.那么就可以使用docker
registry.</p><p>首先需要拉取registry镜像通过</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#586e75>#拉取registry镜像</span>
</span></span><span style=display:flex><span>docker pull registry
</span></span></code></pre></div><p>在本地创建一个私有的镜像服务器dockerhub需要用到的命令</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker run <span style=color:#719e07>-</span>d <span style=color:#719e07>-</span>p <span style=color:#2aa198>5000</span>:<span style=color:#2aa198>5000</span> <span style=color:#719e07>-</span>v <span style=color:#719e07>~</span><span style=color:#dc322f>/Workspace/</span>dockerlearn<span style=color:#dc322f>/:/</span>tmp<span style=color:#719e07>/</span>registry <span style=color:#719e07>--</span>privileged<span style=color:#719e07>=</span>true registry
</span></span></code></pre></div><p>为了测试是否成功搭建并且可以正常推送Docker镜像到这个服务器. 魔改一个ubuntu镜像</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#586e75>#启动一个ubuntu镜像</span>
</span></span><span style=display:flex><span>docker run <span style=color:#719e07>-</span>it ubuntu bash
</span></span><span style=display:flex><span><span style=color:#586e75>#安装vim</span>
</span></span><span style=display:flex><span>apt<span style=color:#719e07>-</span>get update
</span></span><span style=display:flex><span>apt<span style=color:#719e07>-</span>get install <span style=color:#719e07>-</span>y vim
</span></span></code></pre></div><p>镜像修改成功后，通过curl查询私服上的镜像列表</p><pre tabindex=0><code>curl -XGET http://127.0.0.1:5000/v2/_catalog
</code></pre><p>因为什么都没上传过所以是空的。然后上传魔改后的自己的ubuntu镜像.先通过docker tag修改一下镜像名称为私服地址/镜像名称:版本号</p><pre tabindex=0><code>docker tag vimubuntu:0.1.0 127.0.0.1:5000/vimubuntu:0.1.0
</code></pre><p>修改配置docker的配置文件 linux下是<code>/etc/docker/daemon.json</code> 添加私服的ip地址</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#268bd2>&#34;insecure-registers&#34;</span>: [<span style=color:#2aa198>&#34;ip address:port&#34;</span>]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当docker挂在主机目录访问如果出现<code>permission denied</code>提示权限不够时需要加上
<code>--privileged = true</code></p><h3 id=数据卷>数据卷</h3><p>为什么要用数据卷因为镜像往往都是很纯净的甚至都没有vi，还需要去下载一个vi才能使用。如果使用docker部署不推荐在容器内部维护项目。</p><p>数据卷：将宿主机的一个目录映射到容器的一个目录中。可以在宿主机中操作目录中的内容，那么容器内部映射的文件，也会跟着一起改变。</p><p>通过<code>-v 本机目录:容器目录:rw</code>参数将本机目录同步挂载到容器。读写权限默认是<code>rw</code>所以可以写也可以不写.</p><p>创建数据卷后，默认会存放在一个目录下/var/lib/docker/volumes/数据卷名称/_data</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker volume create 数据卷名称
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>#创建一个go微服务数据卷</span>
</span></span><span style=display:flex><span>➜ docker volume create go<span style=color:#719e07>-</span>microservices
</span></span><span style=display:flex><span>go<span style=color:#719e07>-</span>microservices
</span></span><span style=display:flex><span><span style=color:#586e75># 查看数据卷</span>
</span></span><span style=display:flex><span>➜ docker volume ls
</span></span><span style=display:flex><span>DRIVER              VOLUME NAME
</span></span><span style=display:flex><span><span style=color:#b58900>local</span>               <span style=color:#2aa198>3e1</span>a82bbf69dc086edf161d5f5737c108d82f04a1c07fa24be77a48d6f7bd0de
</span></span><span style=display:flex><span><span style=color:#b58900>local</span>               <span style=color:#2aa198>55</span>f0f0294ae7096d461ffc0319c8e52064856d18ce9ceb194794d39420b2c76a
</span></span><span style=display:flex><span><span style=color:#b58900>local</span>               <span style=color:#2aa198>460487207e610918020</span>e8435d071e6127c98f33eb0292433a38a8c8bedaf4f38
</span></span><span style=display:flex><span><span style=color:#b58900>local</span>               dd189a79766f32b8da90ff16a7cc4bf97ef662fcd9387e322232cd60de791a36
</span></span><span style=display:flex><span><span style=color:#b58900>local</span>               go<span style=color:#719e07>-</span>microservices
</span></span></code></pre></div><p>查看全部数据卷信息</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker volume ls
</span></span><span style=display:flex><span><span style=color:#586e75>#查看数据卷的详细信息，可以查询到存放的路径，创建时间等等</span>
</span></span><span style=display:flex><span>docker volume inspect 数据卷名称
</span></span></code></pre></div><p>删除指定的数据卷</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker volume rm 数据卷名称
</span></span></code></pre></div><p>容器映射数据卷通过数据卷名称映射，如果数据卷不存在。Docker会帮你自动创建，会将容器内部自带的文件，存储在默认的存放路径中。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>docker run <span style=color:#719e07>-</span>v 数据卷名称:容器内部的路径 镜像id
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>#通过路径映射数据卷，直接指定一个路径作为数据卷的存放位置。但是这个路径下是空的。手动添加内容，推荐这种方式</span>
</span></span><span style=display:flex><span>docker run <span style=color:#719e07>-</span>v 路径(<span style=color:#dc322f>/root/</span>自己创建的文件夹):容器内部的路径 镜像id
</span></span></code></pre></div><h3 id=dockerfile自定义镜像>Dockerfile自定义镜像</h3><p>创建自定义镜像就需要创建一个Dockerfiler,如下为Dockerfile的语言</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>from：指定当前自定义镜像依赖的环境
</span></span><span style=display:flex><span>copy：将相对路径下的内容复制到自定义镜像中
</span></span><span style=display:flex><span>workdir：声明镜像的默认工作目录
</span></span><span style=display:flex><span>run：执行的命令，可以编写多个
</span></span><span style=display:flex><span>cmd：需要执行的命令（在workdir下执行的，cmd可以写多个，只以最后一个为准）
</span></span></code></pre></div><p>生成镜像</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span><span style=color:#586e75>#编写完Dockerfile后需要通过命令将其制作为镜像，并且要在Dockerfile的当前目录下，之后即可在镜像中查看到指定的镜像信息</span>
</span></span><span style=display:flex><span><span style=color:#586e75># 点意味着生成在当前目录下</span>
</span></span><span style=display:flex><span>docker build <span style=color:#719e07>-</span>t 镜像名称[:tag] <span style=color:#719e07>.</span>
</span></span></code></pre></div><h3 id=dockercompose>DockerCompose</h3><p>以上面的方式运行一个容器需要添加许多参数。为了更加的方便使用Docker-Compose编写配置文件把参数写进去。
Docker-Compose也可以批量的管理容器所以你只需要编写并维护一个docker-compose.yaml文件即可
地址
<a href=https://github.com/docker/compose>docker-compose</a>,可以在github的release下载已经打包好的</p><ul><li>Linux 环境</li></ul><p>下载好docker-compose然后将DockerCompose文件的名称修改一下，给予DockerCompose文件一个可执行的权限</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=display:flex><span>mv docker<span style=color:#719e07>-</span>compose<span style=color:#719e07>-</span>Linux<span style=color:#719e07>-</span>x86_64 docker<span style=color:#719e07>-</span>compose
</span></span><span style=display:flex><span><span style=color:#b58900>chmod</span> <span style=color:#2aa198>777</span> docker<span style=color:#719e07>-</span>compose
</span></span><span style=display:flex><span><span style=color:#586e75>#方便后期操作，配置一个环境变量</span>
</span></span><span style=display:flex><span><span style=color:#586e75>#将docker-compose文件移动到了/usr/local/bin，修改了/etc/profile文件，给/usr/local/bin配置到了PATH中</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mv docker<span style=color:#719e07>-</span>compose <span style=color:#dc322f>/usr/</span><span style=color:#b58900>local</span><span style=color:#719e07>/</span>bin
</span></span><span style=display:flex><span>vi <span style=color:#dc322f>/etc/</span>profile
</span></span><span style=display:flex><span><span style=color:#586e75>#添加内容：export PATH=/usr/local/bin:$PATH</span>
</span></span><span style=display:flex><span>source <span style=color:#dc322f>/etc/</span>profile
</span></span><span style=display:flex><span><span style=color:#586e75>#测试</span>
</span></span><span style=display:flex><span>docker<span style=color:#719e07>-</span>compose <span style=color:#719e07>-</span>v
</span></span></code></pre></div><ul><li>Mac 下如果你安装过了docker for mac app就可以直接使用了</li></ul><h3 id=dockercompose-管理>DockerCompose 管理</h3><p>编写docker-compose.yml文件yml文件以key:value方式来指定配置信息
多个配置信息以换行+缩进的方式来区分在docker-compose.yml文件中，不要使用制表符</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#268bd2>version</span>: <span style=color:#2aa198>&#39;3.1&#39;</span>
</span></span><span style=display:flex><span><span style=color:#268bd2>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#268bd2>mysql</span>:           <span style=color:#586e75># 服务的名称</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>restart</span>: always   <span style=color:#586e75># 代表只要docker启动，那么这个容器就跟着一起启动</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>image</span>: daocloud.io/library/mysql:5.7.4  <span style=color:#586e75># 指定镜像路径</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>container_name</span>: mysql  <span style=color:#586e75># 指定容器名称 docker ps 看到的名称</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#2aa198>3309</span>:<span style=color:#2aa198>3306</span>   <span style=color:#586e75>#  指定端口号的映射</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>environment</span>:
</span></span><span style=display:flex><span>      <span style=color:#268bd2>MYSQL_ROOT_PASSWORD</span>: root   <span style=color:#586e75># 指定MySQL的ROOT用户登录密码</span>
</span></span><span style=display:flex><span>      <span style=color:#268bd2>TZ</span>: Asia/Shanghai        <span style=color:#586e75># 指定时区</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>volumes</span>:
</span></span><span style=display:flex><span>     - ~/docker_mysql/mysql_data:/var/lib/mysql   <span style=color:#586e75># 映射数据卷</span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>go</span>:
</span></span><span style=display:flex><span>    <span style=color:#268bd2>restart</span>: always
</span></span><span style=display:flex><span>    <span style=color:#268bd2>image</span>: go:1.14.7
</span></span><span style=display:flex><span>    <span style=color:#268bd2>container_name</span>: go
</span></span><span style=display:flex><span>    <span style=color:#268bd2>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#2aa198>8080</span>:<span style=color:#2aa198>8080</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>environment</span>:
</span></span><span style=display:flex><span>      <span style=color:#268bd2>TZ</span>: Asia/Shanghai
</span></span><span style=display:flex><span>    <span style=color:#268bd2>volumes</span>:
</span></span><span style=display:flex><span>      <span style=color:#586e75>#填数据卷</span>
</span></span><span style=display:flex><span>  <span style=color:#586e75>#如果还有镜像容器可以一直往下写</span>
</span></span></code></pre></div><h3 id=dockercompose-命令>DockerCompose 命令</h3><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>在使用docker-compose的命令时，默认会在当前目录下找docker-compose.yml文件
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#586e75>#1.基于docker-compose.yml启动管理的容器</span>
</span></span><span style=display:flex><span>docker-compose up -d
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#586e75>#2.关闭并删除容器</span>
</span></span><span style=display:flex><span>docker-compose down
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#586e75>#3.开启|关闭|重启已经存在的由docker-compose维护的容器</span>
</span></span><span style=display:flex><span>docker-compose start|stop|restart
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#586e75>#4.查看由docker-compose管理的容器</span>
</span></span><span style=display:flex><span>docker-compose ps
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#586e75>#5.查看日志</span>
</span></span><span style=display:flex><span>docker-compose logs -f
</span></span></code></pre></div><h3 id=dockercompos配合dockerfile一起使用>DockerCompos配合Dockerfile一起使用</h3><p>docker-compose配合Dockerfile使用，就可以使用docker-compose管理自定义的镜像，它会帮你build然后启动。更加方便</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#268bd2>version</span>: <span style=color:#2aa198>&#39;3.1&#39;</span>
</span></span><span style=display:flex><span><span style=color:#268bd2>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#268bd2>ssm</span>:
</span></span><span style=display:flex><span>    <span style=color:#268bd2>restart</span>: always
</span></span><span style=display:flex><span>    <span style=color:#268bd2>build</span>:            <span style=color:#586e75># 构建自定义镜像</span>
</span></span><span style=display:flex><span>      <span style=color:#268bd2>context</span>: ../      <span style=color:#586e75># 指定dockerfile文件的所在路径</span>
</span></span><span style=display:flex><span>      <span style=color:#268bd2>dockerfile</span>: Dockerfile   <span style=color:#586e75># 指定Dockerfile文件名称</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>image</span>: your_image_name:1.0.1 <span style=color:#586e75>#指定你镜像的名称和版本</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>container_name</span>: 容器名称
</span></span><span style=display:flex><span>    <span style=color:#268bd2>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#2aa198>8081</span>:<span style=color:#2aa198>8080</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>environment</span>:
</span></span><span style=display:flex><span>      <span style=color:#268bd2>TZ</span>: Asia/Shanghai
</span></span></code></pre></div><p>运行</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#586e75>#可以直接基于docker-compose.yml以及Dockerfile文件构建的自定义镜像</span>
</span></span><span style=display:flex><span>docker-compose up -d
</span></span><span style=display:flex><span><span style=color:#586e75># 如果自定义镜像不存在，会自动构建出自定义镜像，如果自定义镜像已经存在，会直接运行这个自定义镜像</span>
</span></span><span style=display:flex><span><span style=color:#586e75>#重新构建自定义镜像</span>
</span></span><span style=display:flex><span>docker-compose build
</span></span><span style=display:flex><span><span style=color:#586e75>#运行当前内容，并重新构建</span>
</span></span><span style=display:flex><span>docker-compose up -d --build
</span></span></code></pre></div></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/docker/ rel=tag>docker</a></li></ul></div></footer></article></main><nav class="pager flex"><div class="pager__item pager__item--next"><a class=pager__link href=/post/datastruct/singlelinklist/ rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>Singlelinklist</p></a></div></nav><script src=https://utteranc.es/client.js repo=glepnir/glepnir.github.io issue-term=title theme=github-dark-orange crossorigin=anonymous async></script></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2023 glepnir.
<span class=footer__copyright-credits></span></div></div></footer></div><script async defer src=/js/menu.js></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script></body></html>